<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Southblock'Blog | Southblock'Blog</title><meta name="author" content="Southblock"><meta name="copyright" content="Southblock"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="通过前文的介绍我们知道，Redis 是使用单线程方式执行命令的，Redis 与客户端交互的模式是 Request-Response 模式，也就是：先由客户端发起请求，请求中包含一条 Redis 命令，Redis 执行完这条命令之后，给客户端返回对应的响应。 如果我们使用多条 Redis 命令组合，实现一个较为复杂的流程，在多个客户端同时执行的情况下，就可能会出现并发问题。 举个例子，我们在 Red">
<meta property="og:type" content="article">
<meta property="og:title" content="Southblock&#39;Blog">
<meta property="og:url" content="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/index.html">
<meta property="og:site_name" content="Southblock&#39;Blog">
<meta property="og:description" content="通过前文的介绍我们知道，Redis 是使用单线程方式执行命令的，Redis 与客户端交互的模式是 Request-Response 模式，也就是：先由客户端发起请求，请求中包含一条 Redis 命令，Redis 执行完这条命令之后，给客户端返回对应的响应。 如果我们使用多条 Redis 命令组合，实现一个较为复杂的流程，在多个客户端同时执行的情况下，就可能会出现并发问题。 举个例子，我们在 Red">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg">
<meta property="article:published_time" content="2026-02-05T15:28:44.553Z">
<meta property="article:modified_time" content="2026-02-05T15:28:44.553Z">
<meta property="article:author" content="Southblock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Southblock\'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-05 23:28:44'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Southblock'Blog"><span class="site-name">Southblock'Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-05T15:28:44.553Z" title="更新于 2026-02-05 23:28:44">2026-02-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>通过前文的介绍我们知道，Redis 是使用<code>单线程</code>方式执行命令的，Redis 与客户端交互的模式是 <code>Request-Response 模式</code>，也就是：先由客户端发起请求，请求中包含一条 Redis 命令，Redis 执行完这条命令之后，给客户端返回对应的响应。</p>
<p>如果我们使用多条 Redis 命令组合，实现一个较为复杂的流程，在多个客户端同时执行的情况下，就可能会出现<code>并发问题</code>。</p>
<p>举个例子，我们在 Redis 中维护了一个商品的库存个数，现在进行秒杀活动，每个用户限只能下一个订单，每个订单最多可以购买 5 件商品，这里需要业务侧在每次减少库存值时，判断库存值是否已经到达 0 ，如果库存减到 0 了，就给用户返回“库存不足”的提示。如果下单的业务逻辑是先使用 GET 命令获取库存值，然后与订单购买的商品个数进行比较，在库存值大于购买个数的时候，才使用 SET 命令更新库存值的话，就会存在下表的并发问题，例如下表展示的这个并发执行顺序。</p>
<table>
<thead>
<tr>
<th><strong>时间</strong></th>
<th><strong>Redis 客户端 A</strong></th>
<th><strong>Redis 客户端 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>执行 GET 命令，获得库存量为 100</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>执行 GET 命令，获得库存量为 100</td>
</tr>
<tr>
<td>T3</td>
<td>判断当前库存充足，执行 -5，得到 95</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>判断当前库存充足，执行 -5，得到 95</td>
</tr>
<tr>
<td>T5</td>
<td>执行 SET 命令，将库存更新为 95</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>执行 SET 命令，将库存更新为 95</td>
</tr>
</tbody></table>
<p>很明显，我们卖出了 10 份商品，但是库存只减少了 5 份，这样就造成 “超卖” 的问题，如果更多客户端并发请求，超卖问题会更加严重。如果我们希望将多条命令组合成一个原子操作，就可以考虑<strong>将这多条命令封装成一个 Lua 脚本，Redis 会以原子方式执行该 Lua 脚本，就不会出现上述并发问题了</strong>。</p>
<h2 id="第一个-Lua-脚本"><a href="#第一个-Lua-脚本" class="headerlink" title="第一个 Lua 脚本"></a>第一个 Lua 脚本</h2><p>Lua 是一门古老的语言，广泛作为其他语言的嵌入脚本，尤其是 C&#x2F;C++，Lua 语言自身的语法简单，运行环境非常轻量级，这也是 Redis 官方选择它作为自身的扩展脚本的原因之一。目前 Lua 语言已经迭代到了 5.4 版本，较之前版本性能有较大提高。</p>
<p>下面我们就来编写一个 Lua 脚本来处理上面提到的库存变更问题，具体的 Lua 脚本如下所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> v1 = redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v1 &gt;= ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> result = v1 - ARGV[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>我们一行行地解析一下这个 Lua 脚本的功能。</p>
<p>第一行是通过 redis.call() 方法执行 Redis 的命令，这里执行的是 GET 命令，查询指定 Key 的值，GET 命令查询到的值会记录到 v1 局部变量中。在 KEYS[1] 这个 Key 中记录的是当前库存量。在 Redis 中执行一段 Lua 脚本的时候，可以传递两组参数，一组是 KEYS 参数，用来记录当前这段 Lua 脚本可能访问到的 Redis Key；另一组是 ARGV 参数，ARGV 数组中的参数不能作为 Redis 中的 Key 值使用，只能作为 Lua 脚本自身的参数使用。</p>
<p>第二行是比较 v1 与 ARGV[1] 参数，ARGV[1] 参数是此次订单购买的商品数，如果 v1 大于 ARGV[1] 参数，则表示库存充足，会执行 if 代码块中的逻辑；如果库存量不足，会直接执行到第七行，返回 false，表示当前 Lua 脚本执行失败。第三行代码会计算最新的库存量并记录到 result 这个局部变量中。第四行再次使用 redis.call() 方法执行 SET 命令，更新 KEYS[1] 的值，也就是库存量。第五行返回 true，表示当前 Lua 脚本执行成功。</p>
<p>接下来我们就可以在 Redis 中执行该脚本了，我们可以使用如下 <code>--eval</code> 命令执行一个 Lua 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ./redis-cli --eval ./updateInventory.lua test1 test2 , 10 100</span><br></pre></td></tr></table></figure>

<p>这里的 updateInventory.lua 是上述 Lua 脚本的文件名称，test1 和 test2 会传入到 KEYS 数组中，然后通过逗号分隔之后的 10 和 100 传入到 ARGV 数组中（示例中没有使用到 test2 和 100 这两个值）。注意，KEYS 和 ARGV 参数中各个参数前后都需要空格进行分隔。</p>
<p>除了这种一次性的执行方式之外，我们还可以通过 SCRIPT LOAD 命令将脚本存储到 Redis 中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ ./redis-cli -x script load &lt; ./updateInventory.lua</span><br><span class="line"></span><br><span class="line">&quot;2f9e5bb00bf2a6739542ca791fbff35b0eea6e89&quot;</span><br></pre></td></tr></table></figure>

<p>这里返回的一串字符串是 updateInventory.lua 脚本的 SHA1 值，也是该脚本在 Redis 脚本缓存中的唯一标识，之后就可以复用该标识来调用 updateInventory.lua 脚本的功能了。我们进入 redis-cli 客户端之后，执行 EVALSHA 命令即可，具体如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVALSHA 2f9e5bb00bf2a6739542ca791fbff35b0eea6e89 1 test1 10000000</span><br></pre></td></tr></table></figure>

<p>最后，我们还可以在 redis-cli 后面添加 <code>--ldb</code> 参数对 Lua 脚本进行调试，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/692256d794ff45c2908c90802551d5c8~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>进入 Debug 状态之后，我们可以输入 s 或是 step 单步执行，如下图所示，在单步执行的时候，执行的 Redis 命令以及返回值都会打印出来：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e83bc825ca64d88bff20c097bd47a8d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>我们还可以使用 break 命令在指定行添加断点，也可以使用 break 命令展示或删除指定行的断点，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f788f652564e88b4fea12b128a58d1~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>在设置断点之后，我们就可以使用 continue 命令将程序直接运行到下一个断点处，同时，也可以使用 print 命令展示全部局部变量值以及指定的局部变量值，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a1d64453be4e63816cdc4b7f9bc97e~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>到此为止，我们的第一个 Lua 脚本的<code>编写</code>、<code>运行</code>、<code>调试</code>方面的知识就介绍完了。下面我们将开始介绍 Redis 执行 Lua 脚本的相关实现了。</p>
<h2 id="Redis-Lua-核心实现"><a href="#Redis-Lua-核心实现" class="headerlink" title="Redis Lua 核心实现"></a>Redis Lua 核心实现</h2><h3 id="Lua-环境初始化"><a href="#Lua-环境初始化" class="headerlink" title="Lua 环境初始化"></a>Lua 环境初始化</h3><p>首先，我们来看 Redis 中与 Lua 脚本执行相关的关键结构体 —— luaCtx，它表示的是 Lua 脚本执行的上下文信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">luaCtx</span> &#123;</span><br><span class="line"></span><br><span class="line">    lua_State *lua; <span class="comment">// 从C语言的角度看，可以把lua_State理解成一个Lua虚拟机，或者是一个可以执行Lua代码的Lua虚拟机主线程。lua_State全局唯一</span></span><br><span class="line"></span><br><span class="line">    client *lua_client;   <span class="comment">// 指向一个fake client，它是用于在Lua脚本中执行Redis命令的client</span></span><br><span class="line"></span><br><span class="line">    dict *lua_scripts;    <span class="comment">// 当前正在执行的脚本对应的SHA1值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> lua_scripts_mem;  <span class="comment">// 缓存脚本使用的内存空间</span></span><br><span class="line"></span><br><span class="line">&#125; lctx;</span><br></pre></td></tr></table></figure>


<p>在 redisServer 结构体中，也有一些与 Lua 脚本相关信息，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">redisServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    client *script_caller; <span class="comment">// 调用EVAL命令，触发Lua脚本执行的client</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mstime_t</span> busy_reply_threshold;  <span class="comment">// 脚本执行超时时间</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他字段</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 Redis 初始化 Lua 脚本环境的核心流程，这部分逻辑位于 scriptingInit() 函数，其核心步骤如下。</p>
<ol>
<li><p>调用 lua_open() 初始化 Lua 脚本解释器，也就是上面 luaCtx-&gt;lua 字段。</p>
</li>
<li><p>加载 Lua 库，这里加载了 Lua 的基础库以及 cjson 库等常用 Lua 库，同时会禁用 loadfile、dofile 等文件读写函数，防止恶意的 Lua 脚本读写 Redis 服务器上的文件。</p>
</li>
<li><p>初始化 luaCtx-&gt;lua_scripts 字典，用于维护 Lua 脚本 SHA1 标识与 Lua 脚本代码之间的映射关系。</p>
</li>
<li><p>注册 Redis 命令，对应的逻辑在 luaRegisterRedisAPI() 函数中，下面截取了其中一段比较有代表性的代码片段，并做了比较详细的分析。这里需要先明确一下，C 语言与 Lua 交互的方式是靠一个虚拟栈来完成的，后面我们还会多次使用到这个虚拟栈来传递数据：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua_newtable()函数用于创建一个table，该table会压入到Lua的栈顶中，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table中注册的内容也就从Redis传递到了Lua脚本中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_newtable</span>(lua); </span><br><span class="line"></span><br><span class="line"><span class="comment">// lua_pushstring()函数是将一个字符串压入到栈顶，下面就是将&quot;call&quot;字符串压入栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_pushstring</span>(lua,<span class="string">&quot;call&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// lua_pushcfunction()函数是将一个C函数指针压入到栈顶，下面就是将luaRedisCallCommand</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针压入栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_pushcfunction</span>(lua,luaRedisCallCommand); </span><br><span class="line"></span><br><span class="line"><span class="comment">// lua_settable()函数是将栈顶的两个元素弹出，第一个弹出的元素作为Key，第二个弹出的元素作为Value，然后将Key和Value设置到table中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_settable</span>(lua,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<p>call 命令以及对应的 luaRedisCallCommand() 函数注册的逻辑如下图所示：</p>
<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4989b7de6454d84a5ace9a3c13ec668~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

<p>同学们可以参考 Redis 源码中<code> /deps/lua/doc/manual.html </code>这个 API 文档来了解 C 语言与 Lua 脚本交互的函数。</p>
<p>除了注册 call 命令之外，这里还会注册 pcall、log、setresp、error_reply、status_reply、replicate_commands、set_repl 等一系列命令以及 LL_VERBOSE、LL_NOTICE、PROPAGATE_AOF、PROPAGATE_REPL 一系列全局和局部变量，它们的注册原理与 call 命令相同，这里就不再一一重复了。</p>
<ol start="5">
<li>在将上述命令和变量都注册到 table 之后，这里会调用 lua_setglobal() 函数，将 table 记录到一个名为 redis 的全局变量中，如下图所示，在 Lua 脚本中就可以通过 “redis.” 的方式调用前面注册到其中的函数了。出于安全方面的考虑，这里还会禁用 Lua 全局变量的读写，防止恶意 Lua 脚本修改 redis table 中注册的函数。</li>
</ol>
<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee777de861184a83bb92ba0a68dcd872~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

<ol start="6">
<li>最后，初始化 luaCtx-&gt;lua_client 字段，后续我们会看到该 client 实例主要用于在 Lua 脚本中执行 Redis 命令，这里会在 client 实例的 flags 中设置 CLIENT_SCRIPT 进行标识，同时还会设置 CLIENT_DENY_BLOCKING 标志位禁止阻塞。</li>
</ol>
<h3 id="redis-call-核心"><a href="#redis-call-核心" class="headerlink" title="redis.call() 核心"></a>redis.call() 核心</h3><p>了解了在 Lua 解释器中注册 Redis 命令的逻辑之后，我们来看 Lua 脚本中 redis.call() 和 pcall() 函数具体是如何执行 Redis 命令的，redis.call() 和 pcall() 函数在底层对应的都是 luaRedisGenericCommand() 函数，两者只是返回值有所不同而已，如下图所示：</p>
<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/639a07d36e134609a92fb8257236b24a~tplv-k3u1fbpfcp-zoom-1.image" alt=""  /></p>

<p>下面是 luaRedisGenericCommand() 函数的核心逻辑。</p>
<ol>
<li><p>首先调用 luaArgsToRedisArgv() 函数，解析 Lua 脚本给 redis.call() 函数传入的参数值。数字类型参数将通过 lua_tonumber() 函数读取，并以 double 形式存储，字符串类型参数将通过 lua_tolstring() 函数读取并存储，最终所有的参数将存储到 argv 数组中。</p>
</li>
<li><p>接下来进入 scriptCall() 函数，它先将解析得到的参数（argv 数组）赋值到 luaCtx.lua_client 这个全局 client 中的 argv 字段，同时会更新 luaCtx.lua_client-&gt;argc 字段，记录参数个数。前面简单提到 luaCtx-&gt;client，它是一个 fake client，专门用来执行 Lua 脚本发出的 Redis 命令。</p>
</li>
<li><p>然后，scriptCall() 会通过 lookupCommand() 函数，根据 luaCtx-&gt;lua_client-&gt;argv[0] 指定的命令名称，查询对应的 redisCommand 实例。</p>
</li>
<li><p>在命令真正执行之前，还有一系列检查。例如，检查 Lua 脚本的 client 是否有执行目标命令的权限；如果目标命令为写操作的话，当前是否有持久化异常禁止写操作执行；检查当前 Redis 内存是否达到最大值，从而禁止命令执行；如果是 Redis Cluster 模式中，目标命令只能访问当前节点管理的 slot 中的 Key。这些检查与正常执行一条命令前的检查基本类似，这里就不再展开一一介绍了，感兴趣的小伙伴可以翻看一下 scriptCall() 函数的源码。</p>
</li>
<li><p>接下来根据 Lua 脚本的配置，设置此次执行的命令能否传播到从库以及 AOF 文件中。这里简单说一下 Redis 对 Lua 脚本中命令进行传播的处理。下面看个例子，其中通过 time 命令随机生成时间戳并写入到 Redis 的是 Lua 实现如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local now = redis.call(&#x27;time&#x27;)[1]; // 执行time命令获取随机时间</span><br><span class="line"></span><br><span class="line">redis.call(&#x27;set&#x27;,&#x27;now&#x27;,now);       // 将随机时间写入到now这个Key中</span><br><span class="line"></span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>在老版本的 Redis 中，这种操作在 Lua 脚本中是不允许的，因为 Lua 脚本对 Redis 数据进行修改之后，会将整个 Lua 脚本持久化到 AOF 文件中，从而保证回放 AOF 能够将 Redis 恢复到当前状态；还会将 Lua 脚本复制给 Slave 执行，从而保证主从一致。但是，如果 Lua 脚本中使用了随机命令，随机命令无法产生一个确定的值，就可能造成主从不一致。</p>
<p>在 Redis 5 中引入了 lua-replicate-commands 配置，用来表示是否开启单行命令的同步特性。开启该特性之后，AOF 和主从复制不再传播整个 Lua 脚本，而是传播单条 Redis 命令；在传播单条命令的时候，Redis 就会对命令进行过改写，从而解决 Lua 脚本中不能使用随机命令的问题。</p>
<p>在 Redis 7 中，只能使用单条命令的方式来传播 Lua 脚本中执行的命令，Lua 脚本方式传播以及 lua-replicate-commands 这个开关也已经都废弃掉了。</p>
<ol start="6">
<li><p>完成上述检查和处理逻辑之后，scriptCall() 函数会调用 call() 函数执行真正的 Redis 命令，其核心逻辑在前面的小节中已经详细分析过了，这里不再重复。</p>
</li>
<li><p>完成 Redis 命令执行之后，这里会开始读取 luaCtx-&gt;client 这个 fake client 的 buf 缓冲区以及 reply 列表，获取 Redis 命令返回值。然后调用 redisProtocolToLuaType() 函数将 Redis 命令返回值转换成 Lua 变量并压入到虚拟栈中。</p>
<p>这里以 redisProtocolToLuaType_Int() 函数为例进行简单说明，其中会先查找 ‘\r’ 结束符，然后 ‘\r’ 字符之前的部分转换成 double 类型，并调用 lua_pushnumber() 函数将其压缩到虚拟栈中，如下图所示：</p>
</li>
</ol>
<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9291f9933b9a49c4a6eff78f0184a09e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

<p>到此为止，Lua 脚本中的 redis.call()、pcall() 调用的核心逻辑就介绍完了。</p>
<h3 id="Lua-脚本执行原理"><a href="#Lua-脚本执行原理" class="headerlink" title="Lua 脚本执行原理"></a>Lua 脚本执行原理</h3><p>介绍完 Lua 脚本内部执行 Redis 命令的逻辑之后，我们来关注触发 Lua 脚本的相关命令，其中我们最常用的、触发 Lua 脚本执行的命令就是 <code>EVAL</code> 命令，其格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>

<p>其中 script 是 Lua 脚本的具体代码，numkeys 是后续 key 参数的个数，这些 key 参数将会转换成 Lua 脚本中 KEYS 数组中的元素值，后续的 arg 参数将转换成 Lua 脚本中的 ARGV 数组中的元素值。前面在命令行窗口中使用 redis-cli –eval 命令执行 Lua 脚本的时候，没有 numkeys 参数，而是使用逗号区分 key 参数和 argv 参数，注意两者的区别。</p>
<p>下面我们来看 EVAL 命令对应的底层实现 —— evalGenericCommand() 函数（EVALSHA 命令的底层也是通过该函数实现的），其核心逻辑如下。</p>
<ol>
<li><p>首先，为 Lua 脚本计算 SHA1 值，该 SHA1 值前面会拼接 “f_” 字符将作为该 Lua 脚本对应的函数名称，我们可以回忆一下前文编写的 Lua 脚本实际上就是一个函数体。计算好 Lua 脚本对应的函数名称之后，这里会调用 lua_getfield() 函数从 Lua 环境中获取同名的全局变量，并将该变量值压入到虚拟栈中。</p>
</li>
<li><p>接下来执行 lua_isnil() 函数检查栈顶值是否空，如果是的话，说明该脚本未被缓存，这里会调用 luaCreateFunction() 函数将 Lua 函数名称和对应的 Lua 脚本写入到 luaCtx-&gt;lua_script 字典中缓存，同时还会调用 luaL_loadbuffer()、lua_pcall() 等函数，将 Lua 脚本加载到虚拟栈顶。如下图所示：</p>
</li>
</ol>
<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecfc29cfafd4d038fc6c0aedbcfdd4b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

<ol start="3">
<li><p>随后，进入 luaCallFunction() 函数。它会将 EVAL 命令中的 key 参数列表，设置到 Lua 全局变量中的 KEYS 数组中，将 EVAL 命令中的 arg 参数列表设置到 Lua 全局变量中的 ARGV 数组中。</p>
</li>
<li><p>luaCallFunction() 函数还会调用 lua_sethook() 函数，将 luaMaskCountHook() 函数设置为 hook 函数，在 Lua 解释器每执行 100000 条指令的时候，就会回调一下 luaMaskCountHook() 函数。</p>
<p>在 luaMaskCountHook() 函数中会比较当前时间戳与 lua_time_start 时间戳来判断当前 Lua 脚本执行是否超时，如果超时了，会在上下文中设置 SCRIPT_TIMEDOUT 标识。然后，在将发起 EVAL 命令的 client 的 flags 中添加 CLIENT_PROTECTED 标记，该标记表示暂时保持与 lua_caller 之间的连接，我们可以在 freeClientsInAsyncFreeQueue() 函数和 freeClient() 函数中看到对应的逻辑：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeClient</span><span class="params">(client *c)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) &#123; <span class="comment">// 如果有CLIENT_PROTECTED标志，会异步释放</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将client添加到redisServer.clients_to_close列表中，</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// clients_to_close列表中记录了等待释放的client</span></span><br><span class="line"></span><br><span class="line">        freeClientAsync(c); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeClientsInAsyncFreeQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    listRewind(server.clients_to_close,&amp;li);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过CLIENT_PROTECTED状态的client</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用freeClient(c)函数释放client以及底层连接</span></span><br><span class="line"></span><br><span class="line">        freeClient(c);</span><br><span class="line"></span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line"></span><br><span class="line">        freed++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以保持该 client 的连接，是为了在 Lua 脚本执行完成或是在被其他客户端 kill 的时候，返回给客户端相应的提示信息。</p>
<p>另外，在发生超时的时候，luaMaskCountHook() 函数还会调用 processEventsWhileBlocked() 函数处理其他客户端请求和定时任务，但是注意，这里只能接受其他客户端发来的 SCRIPT KILL 等几种特殊的控制命令，读写命令就别想了，相应的控制逻辑我们可以在 processCommand() 函数中看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span>&#123;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((scriptIsTimedout() <span class="comment">// 当前Lua脚本执行超时</span></span><br><span class="line"></span><br><span class="line">            || server.busy_module_yield_flags</span><br><span class="line"></span><br><span class="line">         ) &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_ALLOW_BUSY)) &#123; <span class="comment">// 只有CMD_ALLOW_BUSY的命令能执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.busy_module_yield_flags &amp;&amp; server.busy_module_yield_reply) </span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            rejectCommandFormat(c, <span class="string">&quot;-BUSY %s&quot;</span>, </span><br><span class="line"></span><br><span class="line">                    server.busy_module_yield_reply);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.busy_module_yield_flags) &#123;</span><br><span class="line"></span><br><span class="line">            rejectCommand(c, shared.slowmoduleerr); <span class="comment">// 返回BUSY响应</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scriptIsEval()) &#123;</span><br><span class="line"></span><br><span class="line">            rejectCommand(c, shared.slowevalerr); <span class="comment">// 返回BUSY响应</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            rejectCommand(c, shared.slowscripterr); <span class="comment">// 返回BUSY响应</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>介绍完 Lua 脚本超时的处理逻辑之后，我们回到 luaCallFunction() 函数的主线继续分析。接下来，luaCallFunction() 函数可以调用 lua_pcall() 函数执行虚拟栈顶的 Lua 函数了。</p>
<p>如果 Lua 脚本执行失败，lua_pcall() 函数会将错误信息压入到虚拟栈中，此时 Redis 会通过 lua_tostring() 函数从虚拟栈中弹出错误信息，并组装成合适的格式，返回给 lua_caller 客户端；如果 Lua 脚本执行成功，lua_pcall() 会将 Lua 脚本的执行结果压入到虚拟栈，此时 Redis 会从栈顶弹出数据，并通过 luaReplyToRedisReply() 函数将其转换成 Redis 中的类型，返回 lua_caller 客户端。</p>
</li>
<li><p>在 Lua 脚本执行完成之后，会进行一系列清理工作，例如，删除前面注册的 luaMaskCountHook() 超时检查函数、调用 Lua 的垃圾回收器清理 Lua 数据（这里会限制 GC 调用的频率，不是每执行完一次 Lua 脚本就执行一次 GC，而是每执行 50 次 Lua 脚本才会触发一次 Lua 的 GC）、清理超时标识等等。</p>
</li>
</ol>
<p>到此为止，<code>EVAL</code> 、<code>EVALSHA</code> 命令执行 Lua 脚本的核心逻辑就介绍完了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节中，我们重点介绍了 Redis 中 Lua 脚本的基本使用以及 Redis 支持 Lua 脚本的底层原理。首先带着大家一起，写了一个简单的 Lua 脚本，介绍了 Lua 脚本在 Redis 中相关的应用；然后分析了 Redis 中与 Lua 脚本相关的核心结构体；最后介绍了 Redis 执行 Lua 脚本的核心流程和原理。</p>
<p>下一节，我们将一起来看 <strong>Redis 7 新引入的 Function 功能</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io">Southblock</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/">https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hutbzc.github.io" target="_blank">Southblock'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC65%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9AGEO%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southblock</div><div class="author-info__description">个人博客Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hutbzc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hutbzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:southblock@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #26da6f;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Southblock' Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">1.</span> <span class="toc-text">第一个 Lua 脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-Lua-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">Redis Lua 核心实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">Lua 环境初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-call-%E6%A0%B8%E5%BF%83"><span class="toc-number">2.2.</span> <span class="toc-text">redis.call() 核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">Lua 脚本执行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC61%E7%AB%A0%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9APub&amp;Sub%E4%B8%8EShardPub&amp;Sub%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC65%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9AGEO%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" title="无题">无题</a><time datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/" title="无题">无题</a><time datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC68%E7%AB%A0%E2%80%94%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BC%9A%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84Redis%E6%8A%80%E8%83%BD%E6%A0%91%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%99%8B%E5%8D%87%E4%B8%BA%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B/" title="无题">无题</a><time datetime="2026-02-05T15:28:44.553Z" title="发表于 2026-02-05 23:28:44">2026-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Southblock</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>