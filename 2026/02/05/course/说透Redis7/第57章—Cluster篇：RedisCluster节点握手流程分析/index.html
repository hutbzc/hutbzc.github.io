<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Southblock'Blog | Southblock'Blog</title><meta name="author" content="Southblock"><meta name="copyright" content="Southblock"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在上一节中，我们阐述了常见的 Redis 分布式存储方案，了解了 Redis Cluster 的基本概念以及核心结构体的定义。在上一节最后，我们还分析了一个 Redis Cluster 节点启动时的关键流程，其中展开介绍了 nodes.conf 配置文件的加载和格式。 这一节，我们继续分析 Redis Cluster 初始化的另一个核心逻辑 —— 握手流程。 CLUSTER MEET 命令使用过">
<meta property="og:type" content="article">
<meta property="og:title" content="Southblock&#39;Blog">
<meta property="og:url" content="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC57%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9ARedisCluster%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Southblock&#39;Blog">
<meta property="og:description" content="在上一节中，我们阐述了常见的 Redis 分布式存储方案，了解了 Redis Cluster 的基本概念以及核心结构体的定义。在上一节最后，我们还分析了一个 Redis Cluster 节点启动时的关键流程，其中展开介绍了 nodes.conf 配置文件的加载和格式。 这一节，我们继续分析 Redis Cluster 初始化的另一个核心逻辑 —— 握手流程。 CLUSTER MEET 命令使用过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg">
<meta property="article:published_time" content="2026-02-05T16:27:41.307Z">
<meta property="article:modified_time" content="2026-02-05T16:27:41.307Z">
<meta property="article:author" content="Southblock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC57%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9ARedisCluster%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Southblock\'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-06 00:27:41'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Southblock'Blog"><span class="site-name">Southblock'Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-05T16:27:41.307Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-05T16:27:41.307Z" title="更新于 2026-02-06 00:27:41">2026-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一节中，我们阐述了常见的 Redis 分布式存储方案，了解了 Redis Cluster 的基本概念以及核心结构体的定义。在上一节最后，我们还分析了一个 Redis Cluster 节点启动时的关键流程，其中展开介绍了 nodes.conf 配置文件的加载和格式。</p>
<p>这一节，我们继续分析 Redis Cluster 初始化的另一个核心逻辑 —— <strong>握手流程</strong>。</p>
<h2 id="CLUSTER-MEET-命令"><a href="#CLUSTER-MEET-命令" class="headerlink" title="CLUSTER MEET 命令"></a>CLUSTER MEET 命令</h2><p>使用过 Redis Cluster 的小伙伴都知道，我们可以通过 CLUSTER NODES 命令查询节点能感知到的整个Cluster 的信息，该命令的返回与前文介绍的 nodes.conf 文件中的格式类似。</p>
<p>在 Redis Cluster 节点第一次启动的时候，它只能感知到自身的存在，我们可以手动执行 CLUSTER MEET 命令让当前节点感知到指定目标节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; [&lt;cport&gt;]</span><br></pre></td></tr></table></figure>

<p>当 Redis 收到 CLUSTER MEET 命令之后，会调用 clusterStartHandshake() 函数创建目标节点对应的 clusterNode 实例并添加到 clusterState-&gt;nodes 字典中。这里注意新建 clusterNode 的两个字段。</p>
<ul>
<li>一个是 name 字段，因为此时还不知道对端节点的真实名称，所以这里会随机生成一个长度为 40 的字符串暂时作为其 name，也是其在 clusterState-&gt;nodes 字典中的 Key。</li>
<li>另一个是 flags 字段，初始值为 HANDSHAKE|MEET（省略 CLUSTER_NODE_ 前缀），HANDSHAKE 表示当前节点后续会向目标节点发送 PING 请求完成握手，MEET 表示后续会向目标节点发送 MEET 请求加入集群。另外，加入 cluster-&gt;nodes 之前还会先遍历该字典，保证没有节点出现地址重复。</li>
</ul>
<p>下面我们来看 A、B 两个 Redis Cluster 节点握手的示例，下图展示了节点 A 处理完 CLUSTER MEET 命令之后的状态：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b7ee272f6d2433a9e0900fbe97cdf63~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>在 clusterStartHandshake() 中，我们并没有看到当前 Cluster 节点与 CLUSTER MEET 命令指定节点的建连操作，那它们之间的网络连接是什么时机建立的呢？</p>
<p>与前文介绍的 Sentinel 类似，Redis Cluster 会在 serverCron() 函数中调用 clusterCron() 函数完成一些 Cluster 相关的定时任务，例如，这里建连操作以及后续的握手操作。通过下面调用 <strong>clusterCron() 函数</strong>的代码片段我们能看出，clusterCron() 要 100 毫秒才能执行一次，默认配置下，一秒执行 10 次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) clusterCron();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 clusterCron() 函数中会遍历 redisServer.cluster-&gt;nodes 这个字典，检查当前节点与其他 Cluster 节点的连接状态。针对单个 clusterNode 的处理逻辑，位于 clusterNodeCronHandleReconnect() 函数之中，其中先会根据各个 clusterNode 实例的 flags 标记信息，过滤掉下面的几类不需要建连的节点。</p>
<ul>
<li><strong>当前节点自身</strong>，也就是 flags 包含 MYSELF 标记。</li>
<li><strong>未知地址的节点</strong>，也就是 flags 包含 NOADDR 标记。</li>
<li><strong>握手超时的节点</strong>，也就是 flags 包含 HANDSHAKE 标记，但长时间未握手成功的节点，这里判定“长时间未握手成功”的标准是 clusterNode 实例创建时间（也就是它的 ctime 字段值）距当前时间已超过 1 秒。</li>
</ul>
<p>针对通过上述过滤的 clusterNode 实例，clusterNodeCronHandleReconnect() 会为其初始化 link 字段，也就是创建一个 clusterLink 实例以及底层的 connection 实例，然后调用 connConnect() 函数建立与目标 Cluster 节点的网络连接（连接的是对端节点的 cport 端口）。</p>
<p>这里创建 clusterLink 实例的时候，其 node 字段会指向代表对端 Cluster 节点的 clusterNode 实例，因为当前节点是清晰地知道这个连接与哪个 Cluster 节点进行连接的，属于<code>主动发起</code>连接时创建的 clusterLink 实例。</p>
<p>小伙伴们可以回顾一下上一讲中提到的 clusterAcceptHandler() 函数，它监听其他节点发来的建连请求时，也会创建 clusterLink 实例，这个场景属于被动接收，它是不清楚对端节点信息的，所以其 node 字段为 NULL。通过后面分析我们也可以确认，<strong>Redis Cluster 节点之间通信，实际上使用了两个连接，一个主动连接（outing conneciton），一个被动连接（incoming conneciton）</strong> 。</p>
<p>下图展示了节点 A 向节点 B 发起建连成功之后的状态：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66dab0b24e74d9bb36fbeeb764cdd75~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="发送-MEET-消息"><a href="#发送-MEET-消息" class="headerlink" title="发送 MEET 消息"></a>发送 MEET 消息</h2><p>建连成功的回调是 clusterLinkConnectHandler() 函数，在这个回调函数中，会完成下面几件事情。</p>
<ul>
<li>首先是给新建的连接注册可读事件的监听，相应的回调函数是 clusterReadHandler() 函数。</li>
<li>然后，调用 clusterSendPing() 函数，向对端 Cluster 节点发送 MEET 消息。</li>
<li>最后，将 MEET 标记位从对端 Cluster 节点相应的 clusterNode-&gt;flags 字段中清理掉。</li>
</ul>
<p>这里我们需要展开介绍一下 clusterSendPing() 函数，该函数也是向指定的对端节点发送 MEET、PING 或者 PONG 三种消息的核心逻辑所在，下面简单介绍一下这三种消息的含义。</p>
<ul>
<li><strong>MEET 消息</strong>：当 Cluster 节点接收到客户端发送的 CLUSTER MEET 命令时，会在下一个 serverCron() 周期中向目标节点发送 MEET 消息，邀请目标节点加入集群。</li>
<li><strong>PING 消息</strong>：用来检测对端节点是否在线的探活消息。</li>
<li><strong>PONG 消息</strong>：当 Cluster 节点收到对端节点发来的 MEET 消息或者 PING 消息时，会返回一条 PONG 消息作为响应。</li>
</ul>
<p>在发送这三种消息的时候，Redis Cluster 节点都会在其中携带当前节点能感知到的节点信息，这也是 Cluster 实现 Gossip 协议的关键所在，后面也会将这些消息统称为 **<code>Cluster Message</code>**。</p>
<p>在发送 Cluster Message之前，首先需要确认需要携带哪些节点的信息，主要分为两大部分。</p>
<p><strong>第一部分</strong>是当前节点能感知到的 1&#x2F;10 个节点的信息（至少 3 个节点）。也就是从当前节点的 clusterState-&gt;nodes 集合中，随机选择 1&#x2F;10 的节点信息，打包到 Cluster Message 中。在随机选择的过程中，会过滤掉下列 clusterNode 实例。</p>
<ul>
<li>当前节点对应的 clusterNode 实例。在消息的头部已经携带了当前节点的信息，无需重复添加。</li>
<li>flags 字段中包含 PFAIL 标记的 clusterNode 实例。在当前节点长时间没有收到一个节点的任何消息时，就会认为其可能出现了故障（只是可能发生故障，并不是一定发生了故障），会在其对应的 clusterNode-&gt;flags 字段中设置 PFAIL 标记位。后面我们会单独处理包含 PFAIL 标记的节点。</li>
<li>flags 字段包含 HANDSHAKE、NOADDR 或是没有与当前节点建连的 clusterNode，因为当前节点并无法正常感知它们的状态，所以也要过滤掉。</li>
<li>numslots 为 0 的 clusterNode 实例，这种 clusterNode 实例对应的 Cluster 节点不负责管理任何 slot，它们的信息没有任何传播的价值。</li>
</ul>
<p><strong>第二部分</strong>是 clusterState-&gt;nodes 集合中处于 PFAIL 状态的节点。这里会将所有处于 PFAIL 状态的、疑似故障的节点信息，全部添加到此次要发送的 Cluster Message 中。</p>
<p>所以，在 clusterSendPing() 函数中，会看到有两次对 clusterState-&gt;nodes 集合的迭代，一次是为了随机选择 1&#x2F;10 的节点，一次是为了过滤出 PFAIL 状态的节点。</p>
<p>Cluster Message 之所以要携带 1&#x2F;10 的已知节点信息，是为了能够在节点下线检查时间内（cluster_node_timeout * 2，cluster_node_timeout 对应 cluster-node-timeout 配置，默认 15 秒），收到大部分 Cluster 节点发来的信息。在 Redis Cluster 中，一个节点在 cluster_node_timeout &#x2F; 2 的时间内，需要向其他 N-1 个节点发送一次 PING 请求，所以在 cluster_node_timeout * 2 时间内，该节点最少会和剩余的每个节点交互了 8 次（收到对端发来的 4 个 PING 请求以及对端返回的 4 个 PONG 响应），每次交互的数据包中，包含下线节点信息的概率为 1&#x2F;10 的话，那么在 cluster_node_timeout * 2 时间段内感知到某个节点下线的期望值就是 80%，可以大概率收到节点下线的信息。</p>
<p>Cluster Message 之所以要携带 PFAIL 状态的节点信息，是为了将疑似故障的节点快速通知给其他节点，从而进行更快的发起 failover 操作，减少不可用的时间。</p>
<p>一条 Cluster Message 消息分为：<strong>消息基本信息、发送节点信息、集群信息、具体消息以及扩展内容</strong>五部分。在 clusterSendPing() 函数中，先会调用 clusterBuildMessageHdr() 函数创建 clusterMsg 实例并填充其中的消息基本信息、发送节点信息以及集群信息三部分。接下来，clusterSendPing() 函数在两次迭代 clusterState-&gt;nodes 字典的时候，会调用 clusterSetGossipEntry() 函数，将筛选出来的节点信息填充成具体消息内容。最后是 Redis 7.0 新增的扩展部分，clusterSendPing() 将当前 Cluster 节点的 hostname 作为扩展内容填充到 clusterMsg 实例中，<a target="_blank" rel="noopener" href="https://github.com/redis/redis/pull/9530">这是对应的 PR 链接</a>。</p>
<p>填充好一个完整的 Cluster Message 消息之后，clusterSendPing() 会根据其实际长度，修正消息基本信息中的消息总长度、节点个数以及扩展内容的条数等信息。Cluster Message 消息的具体格式我们在下一小节展开分析，现在只需要了解 Cluster Message 中有下图展示的五个逻辑部分即可：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ae5ed857132447a926c6680300c0b0a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>完成 clusterMsg 实例的创建和填充之后，当前节点会调用 clusterSendMessage() 函数将 clusterMsg 添加到发送缓冲区中，也就是对应 clusterLink 连接的 sndbuf 缓冲区中，同时还会开始监听该连接上的可写事件，可写事件的回调为 clusterWriteHandler() 函数。</p>
<p>clusterWriteHandler() 函数的实现比较简单，其中就是调用 clusterLink 底层 connection 的 connWrite() 函数向对端节点发送数据，同时将已成功发送的数据从 sndbuf 缓冲区截掉。</p>
<p>下图展示了节点 A 向节点 B 发送完 MEET 消息之后的状态：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1cb9a6b16e6441ea523f427e771bf93~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="Cluster-Message-消息"><a href="#Cluster-Message-消息" class="headerlink" title="Cluster Message 消息"></a>Cluster Message 消息</h2><p>了解了筛选节点信息的规则以及 Cluster Message 消息的发送流程之后，我们展开介绍一下 Cluster Message 消息的结构体定义。</p>
<p>首先是 clusterMsg 结构体，其中包含了我们前面说的五个逻辑部分：消息基本信息、发送节点信息、集群信息、具体消息以及扩展部分，我们一个个来介绍。</p>
<ul>
<li><p>首先来看消息自身的一些基本信息，包括：<strong>消息签名</strong>（sig 字段）、<strong>消息版本</strong>（ver 字段）<strong>、消息长度</strong>（totlen 字段）、<strong>消息类型</strong>（type 字段）、<strong>携带的节点信息条数</strong>（count 字段）。</p>
</li>
<li><p>然后来看消息发送节点的相关信息，包括：<strong>发送节点的名称</strong>（sender 字段）、<strong>当前节点的 configEpoch 信息</strong>（configEpoch 字段）、<strong>主从复制的 Replication Offset</strong>（offset 字段）、<strong>节点的 ip、port 以及 cport</strong>、<strong>当前节点的 flags 状态信息</strong>、<strong>当前节点负责的 slot 集合</strong>（myslots 字段）、<strong>当前节点的主节点名称</strong>（slaveof 字段）。</p>
</li>
<li><p>接下来看集群相关的信息：<strong>当前的 currentEpoch 值</strong>（currentEpoch 字段）。</p>
</li>
<li><p>之后来看具体消息内容：data 字段是一个 clusterMsgData 实例，注意 clusterMsgData 是一个 union，其中可以嵌套 ping、fail、publish、update 等结构体中的一个。这里我们先重点来看 ping 结构体，其中包含了一个 clusterMsgDataGossip 数组，具体定义如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PING、MEET、PONG三种消息都是使用ping这个结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//clusterMsgDataGossip数组，每个clusterMsgDataGossip就包含一个节点的信息</span></span><br><span class="line"></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125; ping;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他结构体的定义</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ping.gossip 数组中的每个 clusterMsgDataGossip 元素，都对应了一个节点信息，其中包含了节点的名称、当前节点最后一次向其发送 PING 消息以及收到 PONG 响应的时间戳、节点的 IP、port、cport 信息以及节点的 flags 标识。</p>
<ul>
<li>在 Redis 7.0 的实现中，最后的 hostname 扩展部分实际上是一个 clusterMsgPingExt 实例，但是它也会被写入到 ping.gossip 数组末尾，占一个数组元素的位置。</li>
</ul>
<h2 id="处理-MEET-消息"><a href="#处理-MEET-消息" class="headerlink" title="处理 MEET 消息"></a>处理 MEET 消息</h2><p>握手流程发送 MEET 消息的核心内容已经介绍完了，下面继续分析对端节点在接收到 MEET 消息时的操作。</p>
<p>这里需要我们回忆一下本节前面“发送 MEET 消息”部分的内容，当两个 Redis Cluster 节点建连之后，会开始监听连接上的可读事件，对应的回调为 clusterReadHandler() 函数。clusterReadHandler() 函数中没有像 readQueryFromClient() 函数（处理客户端连接可读事件的回调函数）那样向 IO 线程转发的逻辑，所以 clusterReadHandler() 函数的全部逻辑是在主线程中执行的。</p>
<p>clusterReadHandler() 函数最核心的逻辑就是一个 while 循环，它不断读取连接中的数据并暂存到 clusterLink-&gt;rcvbuf 缓冲区中。读取过程中会先检查 sig 签名，然后通过检查消息中的 totlen 长度判断是否读取到了一个完整的 clusterMsg 消息，如果能读取到一个完整的 clusterMsg 消息，会将读取到的 clusterMsg 消息交给 clusterProcessPacket() 函数处理，处理完成之后继续下一条消息的读取和处理，直至连接中无数据可读。</p>
<p>下面我们展开分析 <strong>clusterProcessPacket() 函数处理 MEET 消息</strong>的核心流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他类型消息的处理</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line"></span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint16_t</span> count = ntohs(hdr-&gt;count); <span class="comment">// 计算这种消息类型的预计长度</span></span><br><span class="line"></span><br><span class="line">        explen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line"></span><br><span class="line">        explen += (<span class="keyword">sizeof</span>(clusterMsgDataGossip)*count); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.根据消息类型（type 字段）检查消息的长度是否合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hdr-&gt;mflags[<span class="number">0</span>] &amp; CLUSTERMSG_FLAG0_EXT_DATA) &#123;</span><br><span class="line"></span><br><span class="line">            clusterMsgPingExt *ext = getInitialPingExt(hdr, count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (extensions--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">uint16_t</span> extlen = getPingExtLength(ext);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extlen % <span class="number">8</span> != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((totlen - explen) &lt; extlen) &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                explen += extlen;</span><br><span class="line"></span><br><span class="line">                ext = getNextPingExt(ext);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((type == CLUSTERMSG_TYPE_MEET || myself-&gt;ip[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &amp;&amp;</span><br><span class="line"></span><br><span class="line">            server.cluster_announce_ip == <span class="literal">NULL</span>) &#123; <span class="comment">// 2.更新当前 Cluster 节点自身的 IP 地址</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> ip[NET_IP_STR_LEN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (connSockName(link-&gt;conn,ip,<span class="keyword">sizeof</span>(ip),<span class="literal">NULL</span>) != <span class="number">-1</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">strcmp</span>(ip,myself-&gt;ip))</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(myself-&gt;ip,ip,NET_IP_STR_LEN);</span><br><span class="line"></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;IP address for this node updated to %s&quot;</span>,</span><br><span class="line"></span><br><span class="line">                    myself-&gt;ip);</span><br><span class="line"></span><br><span class="line">                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.在两个节点第一次握手的时候，当前 Cluster 节点肯定是查找不到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对端 Cluster 节点对应的 clusterNode 实例的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line"></span><br><span class="line">            clusterNode *node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            node = createClusterNode(<span class="literal">NULL</span>,CLUSTER_NODE_HANDSHAKE);</span><br><span class="line"></span><br><span class="line">            serverAssert(nodeIp2String(node-&gt;ip,link,hdr-&gt;myip) == C_OK);</span><br><span class="line"></span><br><span class="line">            node-&gt;port = ntohs(hdr-&gt;port);</span><br><span class="line"></span><br><span class="line">            node-&gt;pport = ntohs(hdr-&gt;pport);</span><br><span class="line"></span><br><span class="line">            node-&gt;cport = ntohs(hdr-&gt;cport);</span><br><span class="line"></span><br><span class="line">            clusterAddNode(node);</span><br><span class="line"></span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.当前节点会调用 clusterProcessGossipSection() 函数解析消息中携带的 clusterMsgDataGossip 数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line"></span><br><span class="line">            clusterProcessGossipSection(hdr,link);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.调用 clusterSendPing() 函数返回一个 PONG 消息给对端节点</span></span><br><span class="line"></span><br><span class="line">        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先，根据消息类型（type 字段）检查消息的长度是否合法。该步骤也是后续所有消息处理的第一步，后续将不再重复该步骤。</p>
</li>
<li><p>更新当前 Cluster 节点自身的 IP 地址。在当前 Cluster 节点自己的地址发生变更的时候，我们可以通过新建连接获取本机的最近地址，这个地址就是当前 Cluster 变更后的 IP 地址。</p>
</li>
<li><p>接下来，根据请求中携带的对端节点名称，从 clusterState-&gt;nodes 字典中查找对应的 clusterNode 实例（即代码中的 sender 变量）。在两个节点第一次握手的时候，当前 Cluster 节点肯定是查找不到对端 Cluster 节点对应的 clusterNode 实例的。此时，当前节点会为发送 MEET 消息的对端节点创建一个 clusterNode 实例（其 name 字段值是随机生成的，flags 字段中设置了 HANDSHAKE 标志位），并记录到 clusterState-&gt;nodes 字典中，如下图所示。</p>
</li>
<li><p>接下来，当前节点会调用 clusterProcessGossipSection() 函数解析消息中携带的 clusterMsgDataGossip 数组。但是，在第一次接收到未知节点（也就是不在 clusterState-&gt;nodes 字典中节点）发来的 MEET 消息时，并不会直接信任它的 Gossip 信息，所以此次调用没有进行什么有效操作，clusterProcessGossipSection() 函数的其他逻辑先按下不表。</p>
</li>
<li><p>最后，调用 clusterSendPing() 函数返回一个 PONG 消息给对端节点。PONG 消息的组装和发送逻辑与前文分析 MEET 消息的完全一致，这里不再重复。</p>
</li>
</ol>
<p>下图展示了 B 节点处理完 MEET 消息之后两个节点的状态：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e736b8317324faba1875d5b1ac37ba7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="处理-PONG-消息"><a href="#处理-PONG-消息" class="headerlink" title="处理 PONG 消息"></a>处理 PONG 消息</h2><p>我们再回到发送 MEET 消息的这一侧，当前它接收到 PONG 响应的时候，也是通过 clusterProcessPacket() 函数进行处理的，但 PONG 和 MEET 消息类型不同，会进入不同的处理分支。在开始介绍 PONG 消息处理分支之前，先需要明确一点：因为接收 PONG 消息的 clusterLink 连接中的 node 字段指向了表示对端节点的 clusterNode 实例，所以当前节点能够清晰知道发送 PONG 消息的节点身份。</p>
<p>下面来看 clusterProcessPacket() 函数处理 PONG 消息的核心逻辑。根据 PONG 消息中携带的节点名称从 clusterState-&gt;nodes 集合中查找节点，依旧是查找不到，如上图所示，PONG 消息携带的是 Name B，而 A 节点记录的是 Random Name B。下图代码所示，接下来会进入 PONG 消息的处理分支。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e1a513b9d84827b4fbddbfa888f24b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>在 PONG 处理分支中，会使用 PONG 携带的节点名称替换随机生成的对端节点名称，同时还会修改对端节点的 flags：一个是删除 HANDSHAKE 标志位，表示握手结束；一个是设置 MASTER 和 SLAVE 标志位，后续流程会判断对端节点是 Master 还是 Slave。相关代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line"></span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET) &#123; <span class="comment">// PONG消息的处理分支</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;inbound) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link-&gt;node) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nodeInHandshake(link-&gt;node)) &#123; <span class="comment">//包含HANDSHAKE标志位，处于握手状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sender) &#123;...&#125; <span class="comment">// 此时sender为NULL，不会走该分支</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 握手状态下，会用PONG携带的name替换当前节点为对端节点随机生成的name</span></span><br><span class="line"></span><br><span class="line">                clusterRenameNode(link-&gt;node, hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除HANDSHAKE，表示握手结束</span></span><br><span class="line"></span><br><span class="line">                link-&gt;node-&gt;flags &amp;= ~CLUSTER_NODE_HANDSHAKE;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置MASTER和SLAVE标志位</span></span><br><span class="line"></span><br><span class="line">                link-&gt;node-&gt;flags |= </span><br><span class="line"></span><br><span class="line">                        flags&amp;(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置CLUSTER_TODO_SAVE_CONFIG标志位</span></span><br><span class="line"></span><br><span class="line">                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成 Cluster 节点名称更新以及相关状态更新之后，PONG 消息的处理分支会将对端 Cluster 节点对应的 pong_received 字段更新为当前时间戳，同时还会将 ping_sent 字段更新为 0 ，为下次发送 PING 请求做准备。</p>
<p>下图展示了节点 A 处理完节点 B 返回的 PONG 消息之后的状态：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/362a31b6e5664ecda2ef0085ac716223~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="发送-PING-消息"><a href="#发送-PING-消息" class="headerlink" title="发送 PING 消息"></a>发送 PING 消息</h2><p>继续上面的示例，在节点 A 处理完节点 B 返回的 PONG 消息之后，就已经可以正确感知到节点 B 了，并且明确知晓自己与节点 B 之间网络连接。接下来，A 节点就可以通过该连接定时向节点 B 发送 PING 命令进行探活了。但是，此时的节点 B 缺失了节点 A 的很多信息，例如：</p>
<ul>
<li>不知道节点 A 的 name 值是什么。因为处理 MEET 消息时创建的 clusterNode 实例中，name 是随机生成的，并不是节点 A 真正的 name。</li>
<li>不知道自身与节点 A 的连接是哪个。因为被动创建的 clusterLink 实例中的 node 为 NULL。</li>
</ul>
<p>节点 A、B 之间的连接状态如下图所示，只存在 A 到 B 的主动连接，不存在 B 到 A 的主动连接：</p>
<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5182d7aa05854809adaa54e85c418bcf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p>

<p>在节点 B 的下一次执行 clusterCron() 函数迭代自身 clusterState-&gt;nodes 字典的时候，就会发现节点 A 对应的 clusterNode 实例（其 name 此时还是 Random Node A）中，link 字段为 NULL。此时，会触发前文介绍的建连操作，创建节点 B 到节点 A 的主动连接。</p>
<p>通过前文的分析可知，节点 A 的 flags 中只设置了 HANDSHAKE 标志位，未设置 MEET 标记位，所以这里建连完成之后，只会调用 clusterSendPing() 函数发送的一条 PING 消息。节点 A 收到 PING 消息之后会返回一条 PONG 消息，节点 B 在收到 PONG 消息之后，会更新节点 A 的 name，清除 HANDSHAKE 标志位，并更新 ping_sent 和 pong_received 时间戳。</p>
<p>下图展示了节点 B 主动与节点 A 建连的全流程：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a957fde6994a2ca55d38e1b89f7770~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>到此为止，A、B 两个 Redis Cluster 节点之间的握手流程才算完整结束了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本节中，我们重点介绍了 Redis Cluster 节点在启动之后，与集群中其他 Redis Cluster 节点握手的核心流程。</p>
<p>首先，我们介绍了 CLUSTER MEET 命令的使用，它可以让一个 Redis Cluster 节点主动感知到其他节点。接下来，我们深入到 Redis 的实现中，以 CLUSTER MEET 命令执行流程为切入点，按照节点之间的建连过程、发送以及处理 MEET 消息、发送 PONG 响应以及发送 PING 消息的流程分析了两个 Redis Cluster 握手的全过程。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io">Southblock</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC57%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9ARedisCluster%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC57%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9ARedisCluster%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hutbzc.github.io" target="_blank">Southblock'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC55%E7%AB%A0%E2%80%94Sentinel%E7%AF%87%EF%BC%9ASentinel%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC58%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E4%B8%8Eslot%E5%88%86%E9%85%8D%E8%A7%A3%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southblock</div><div class="author-info__description">个人博客Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hutbzc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hutbzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:southblock@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #26da6f;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Southblock' Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLUSTER-MEET-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">CLUSTER MEET 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81-MEET-%E6%B6%88%E6%81%AF"><span class="toc-number">3.</span> <span class="toc-text">发送 MEET 消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cluster-Message-%E6%B6%88%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">Cluster Message 消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86-MEET-%E6%B6%88%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">处理 MEET 消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86-PONG-%E6%B6%88%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">处理 PONG 消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81-PING-%E6%B6%88%E6%81%AF"><span class="toc-number">7.</span> <span class="toc-text">发送 PING 消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC61%E7%AB%A0%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9APub&amp;Sub%E4%B8%8EShardPub&amp;Sub%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC65%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9AGEO%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC68%E7%AB%A0%E2%80%94%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BC%9A%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84Redis%E6%8A%80%E8%83%BD%E6%A0%91%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%99%8B%E5%8D%87%E4%B8%BA%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Southblock</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>