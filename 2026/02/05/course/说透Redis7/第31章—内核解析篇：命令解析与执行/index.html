<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Southblock'Blog | Southblock'Blog</title><meta name="author" content="Southblock"><meta name="copyright" content="Southblock"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在上一节中，我们详细分析了 IO 线程的一些内容以及 readQueryFromClient() 函数的逻辑，这些都是我们理解 Redis 多线程模式下读取客户端请求核心所在。 在 readQueryFromClient() 函数中读取到 client-&gt;querybuf 缓冲区的都是一个个的字节，Redis Server 接下来要做的就是，把这个 byte 数组中的内容，按照一定的规则，解">
<meta property="og:type" content="article">
<meta property="og:title" content="Southblock&#39;Blog">
<meta property="og:url" content="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC31%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/index.html">
<meta property="og:site_name" content="Southblock&#39;Blog">
<meta property="og:description" content="在上一节中，我们详细分析了 IO 线程的一些内容以及 readQueryFromClient() 函数的逻辑，这些都是我们理解 Redis 多线程模式下读取客户端请求核心所在。 在 readQueryFromClient() 函数中读取到 client-&gt;querybuf 缓冲区的都是一个个的字节，Redis Server 接下来要做的就是，把这个 byte 数组中的内容，按照一定的规则，解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg">
<meta property="article:published_time" content="2026-02-05T16:27:41.304Z">
<meta property="article:modified_time" content="2026-02-05T16:27:41.304Z">
<meta property="article:author" content="Southblock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC31%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Southblock\'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-06 00:27:41'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Southblock'Blog"><span class="site-name">Southblock'Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-05T16:27:41.304Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-05T16:27:41.304Z" title="更新于 2026-02-06 00:27:41">2026-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一节中，我们详细分析了 IO 线程的一些内容以及 readQueryFromClient() 函数的逻辑，这些都是我们理解 Redis 多线程模式下读取客户端请求核心所在。</p>
<p>在 readQueryFromClient() 函数中读取到 client-&gt;querybuf 缓冲区的都是一个个的字节，Redis Server 接下来要做的就是，<strong>把这个 byte 数组中的内容，按照一定的规则，解析成 Redis Server 能够理解的命令</strong>。这部分逻辑就是在 readQueryFromClient() 函数最后调用的 <code>processInputBuffer() 函数</code>中完成的。</p>
<h2 id="RESP-协议基础知识"><a href="#RESP-协议基础知识" class="headerlink" title="RESP 协议基础知识"></a>RESP 协议基础知识</h2><p>不过，在开始 processInputBuffer() 函数的介绍之前，我们需要先说一些 Redis 命令解析的基础知识。</p>
<p><strong>第一个基础知识点是 Redis 客户端的请求类型</strong>，对应的是 client-&gt;reqtype 字段，它有两个可选值 PROTO_REQ_INLINE、PROTO_REQ_MULTIBULK。其中，INLINE 是内联请求类型，一般是 Telnet 这种客户端发出来的请求，会使用 INLINE 类型的请求；MULTIBULK 是协议请求类型，我们用的 redis-cli 客户端、Lettuce 客户端发送的都是 MULTIBULK 类型的请求。</p>
<p><strong>第二个知识点是 RESP 协议</strong>。RESP 协议是客户端与 Redis Server 进行交互的基础协议，小伙伴们可以把它理解成客户端和 Redis Server 沟通的一种语言，比如汉语、英语，只有两边都说同一种语言，才能正常交互，RESP 协议现在有 v2 和 v3 两个版本。这两个版本的 RESP 协议的完整描述参考下面这两个链接。</p>
<ul>
<li><p>RESP v2 协议：<a target="_blank" rel="noopener" href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP2.md">https://github.com/redis/redis-specifications/blob/master/protocol/RESP2.md</a></p>
</li>
<li><p>RESP v3 协议：<a target="_blank" rel="noopener" href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md</a></p>
</li>
</ul>
<p>对大多数小伙伴们来说，通读这两个版本的 RESP 协议，可能是一件非常枯燥、无趣且耗时的事情。为了减轻小伙伴们的痛苦呢，下面我们就结合几个示例，一起来分析一下 RESP 2 和 RESP 3 里面常见的一些内容。</p>
<p>无论是 RESP 2 还是 RESP 3 里面，客户端都是以字符串数组的形式把命令以及命令参数等信息发到 Redis Server，大概的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of arguments&gt; \r\n</span><br><span class="line">$&lt;number of bytes of argument <span class="number">1</span>&gt; \r\n</span><br><span class="line">&lt;argument data&gt; \r\n</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; \r\n</span><br><span class="line">&lt;argument data&gt; \r\n</span><br></pre></td></tr></table></figure>

<p>在 Redis 客户端发送“SET testKey testValue” 这条请求的时候，实际上发送的是：<code>*3\r\n$3\r\nSET\r\n$7\r\ntestKey\r\n$9\r\ntestValue\r\n</code> 。</p>
<p>其中，<code>*</code> 表示一个 Array（数组）的开头，Array 是 RESP 中定义的一种类型，<code>*</code> 后面需要紧跟数组的长度，然后后面再跟数组的具体元素，每个元素都可以是下面四种类型的一种。</p>
<ul>
<li><p>Simple String 表示的是一个非二进制安全字符串，里面不能携带 <code>\r\n</code> 这些字符，所以说是非二进制安全的。Simple String 使用 “+” 开头，后面紧跟具体的字符串内容。</p>
</li>
<li><p>Error 表示的是一个非二进制安全的错误信息。其实，Error 和 Simple String 差不多，唯一的区别就是：Error 是以 “-” 这个字符开头的。</p>
</li>
<li><p>Integer 表示的是一个整数，它的第一个字符是“:”，后面紧跟具体的整数值。</p>
</li>
<li><p>Bulk String 表示的是一个二进制安全的字符串，它由两行构成，第一行以“$”字符开头，后面紧跟字符串长度，然后 <code>\r\n</code> 结束；第二行就是具体的字符串内容，然后也是以 <code>\r\n</code> 结束。</p>
</li>
</ul>
<p>经过上面的介绍，我们就大概知道“SET testKey testValue”这条请求的换分方式了，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b47dea04137f44a389f54c40b4443e7b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上面这些数据类型，在 RESP 2 中其实就已经支持了，在 RESP 3 中也是兼容的。在 Redis 6 中为了支持客户端缓存，也为了让 RESP 的语义更加丰富，引入了 RESP 3 协议。在 Redis 6 中，redis-cli 客户端默认还是 RESP 2 协议，我们可以使用 HELLO 命令查看当前客户端使用的 RESP 协议版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hello</span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;server&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;redis&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;version&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;7.0.0&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;proto&quot;</span></span><br><span class="line"> <span class="number">6</span>) (integer) <span class="number">2</span> <span class="comment">// 这里就是当前使用的RESP版本</span></span><br><span class="line">... <span class="comment">// 省略后续输出</span></span><br></pre></td></tr></table></figure>

<p>我们可以执行 HELLO 3 命令将当前客户端切换到 RESP 3 协议，如下，不仅返回的 proto 值变了，整个输出格式也都变了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hello <span class="number">3</span></span><br><span class="line"><span class="number">1</span># <span class="string">&quot;server&quot;</span> =&gt; <span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="number">2</span># <span class="string">&quot;version&quot;</span> =&gt; <span class="string">&quot;7.0.0&quot;</span></span><br><span class="line"><span class="number">3</span># <span class="string">&quot;proto&quot;</span> =&gt; (integer) <span class="number">3</span> <span class="comment">// 这里就是当前使用的RESP版本</span></span><br><span class="line">... <span class="comment">// 省略后续输出</span></span><br></pre></td></tr></table></figure>


<p>RESP 3 协议不仅兼容了 RESP 2 中的数据类型，还新增了十多种的数据类型。这里结合几个例子来介绍一下 RESP 3 中的新类型，比如，在 RESP 3 中引入了 Map 这种新类型，它的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&lt;number of key-value&gt; \r\n</span><br><span class="line">&lt;key-type&gt;&lt;key&gt; \r\n</span><br><span class="line">&lt;value-type&gt;&lt;value&gt; \r\n</span><br><span class="line">&lt;key-type&gt;&lt;key&gt; \r\n</span><br><span class="line">&lt;value-type&gt;&lt;value&gt; \r\n</span><br></pre></td></tr></table></figure>

<p>假设我们在 Redis 里面存储了一个叫 testMap 的哈希表结构，用 JSON 表示其具体内容的话，是下面这样一段 JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;kouzhao&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们用 HGETALL 命令查询 testMap 中全部键值对的时候，会返回下图展示的结构。其中，“%” 表示一个 Map 类型的结构，后面紧跟键值对的个数，然后依次是各组键值对，每个 Key 和 Value 都是 Bulk String 类型的值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f2a5e017b14636bb6314ca45fce532~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>再比如说，我们在 Redis 里面存储了一个叫 testZset 的有序集合，用 JSON 表示其具体内容的话，是下面这段 JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;first&quot;</span> <span class="punctuation">,</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;second&quot;</span> <span class="punctuation">,</span></span><br><span class="line">        <span class="number">2</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>



<p>我们用 <code>ZRANGE testZSet 0 -1 WITHSCORES</code> 命令查询 testZset 中全部元素以及 score 值的时候，会返回下图展示的结构。其中需要注意的是，Double 类型使用 “,” 开头。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/987e13bcdc734bddb86083e150e90999~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>RESP 3 中除了引入 Map、Double 这两个新类型之外，还引入了 Set、Attribute、Push、NULL、Stream String，等等。这里我们就不再一一展开介绍了，想要深入了解 RESP 3 协议中所有新类型的小伙伴，可以参考<a target="_blank" rel="noopener" href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">这篇文档</a>。</p>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p>介绍完 Redis 命令解析的前置基础之后，我们就可以开始详细讲解命令解析的逻辑了。</p>
<p>正如前文所述，<strong>processInputBuffer() 函数是命令解析和命令执行的入口，其中会通过一个 while 循环不停地解析命令，直到把 client-&gt;querybuf 缓冲区中所有的命令处理完</strong>，下面是其核心流程图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d8e0252f954887b6321636e446b6d5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>下面是 processInputBuffer() 函数的核心代码和注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// qb_pos字段用来记录querybuf的读取位置</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123; </span><br><span class="line">        ... <span class="comment">// 忽略其他异常处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</span><br><span class="line">            <span class="comment">// reqtype字段指定了该客户端发出的请求协议类型</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[c-&gt;qb_pos] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_INLINE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不同协议类型走不同的命令解析函数</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123; </span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>; </span><br><span class="line">            ... <span class="comment">// 省略非核心逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未知请求类型，输出日志并结束进程 &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在IO线程读取请求的时候，io_threads_op这个全局变量的值是IO_THREADS_OP_READ，</span></span><br><span class="line">        <span class="comment">// 所以正常解析请求的时候，一定会走进下面的分支。里面会给client添加</span></span><br><span class="line">        <span class="comment">// CLIENT_PENDING_COMMAND标志位，表示该client中有一条待执行的命令，</span></span><br><span class="line">        <span class="comment">// 同时，里面的break会结束当前这条命令的解析过程</span></span><br><span class="line">        <span class="keyword">if</span> (io_threads_op != IO_THREADS_OP_IDLE) &#123;</span><br><span class="line">            serverAssert(io_threads_op == IO_THREADS_OP_READ);</span><br><span class="line">            c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为上面CLIENT_PENDING_READ标记为的处理，IO线程中不会执行到这里</span></span><br><span class="line">        <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 省略了针对主从复制对querybuf复用的一些优化逻辑，这个优化点在主从复制的小节里面再说</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;qb_pos) &#123; <span class="comment">// 将已经解析的命令从querybuf缓冲区中删除</span></span><br><span class="line">        sdsrange(c-&gt;querybuf,c-&gt;qb_pos,<span class="number">-1</span>);</span><br><span class="line">        c-&gt;qb_pos = <span class="number">0</span>; <span class="comment">// 重置qb_pos</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们在实际生产中，使用最多的还是 redis-cli 以及 Lettuce 这类客户端，所以这里我们重点关注 MULTIBULK 请求的解析流程，也就是 <code>processMultibulkBuffer() 函数</code>。</p>
<p>首先，processMultibulkBuffer() 会读取请求中第一行，确定数组中有多少个，相应的代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multibulklen字段用来记录此次multibulk请求中剩余要读取的参数个数，</span></span><br><span class="line"><span class="comment">// 此时是0，表示还未初始化，我们要读取第一行数据</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在querybuf缓冲区中搜索&#x27;\r&#x27;这个分隔字符</span></span><br><span class="line">    newline = <span class="built_in">strchr</span>(c-&gt;querybuf+c-&gt;qb_pos,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    ... <span class="comment">// 省略异常处理</span></span><br><span class="line">    <span class="comment">// 将第一行数据转换成整数，并记录到multibulklen这个字段中</span></span><br><span class="line">    ok = string2ll(c-&gt;querybuf+<span class="number">1</span>+c-&gt;qb_pos,</span><br><span class="line">              newline-(c-&gt;querybuf+<span class="number">1</span>+c-&gt;qb_pos),&amp;ll);</span><br><span class="line">    c-&gt;multibulklen = ll; </span><br><span class="line">    c-&gt;qb_pos = (newline-c-&gt;querybuf)+<span class="number">2</span>; <span class="comment">// 后移qb_pos值</span></span><br><span class="line">    <span class="comment">// argv字段用来记录解析后的参数</span></span><br><span class="line">    c-&gt;argv_len = min(c-&gt;multibulklen, <span class="number">1024</span>);</span><br><span class="line">    c-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;multibulklen);</span><br><span class="line">    c-&gt;argv_len_sum = <span class="number">0</span>; <span class="comment">// argv_len_sum字段用来记录请求参数解析后的总长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>确定元素个数之后， processMultibulkBuffer() 会开始逐个解析数组中的元素。根据 RESP 协议，请求中每个数组元素都是 Bulk String 类型，这里会一个个数组元素进行解析。我们以第一个元素的解析为例：</p>
<ul>
<li><p>首先是读取第一个元素的第一行，确定它是以 “$” 字符开头的，然后通过这行的数字，也就确定了这个字符串的具体长度，该长度值会记录到 client-&gt;bulklen 字段中；</p>
</li>
<li><p>然后，根据字符串长度，读取第二行，拿到字符串的具体内容，并对请求进行解析。</p>
</li>
</ul>
<p>下面是 processMultibulkBuffer() 函数解析请求的核心代码片段，其中删除了很多不重要的分支，只保留了最关键的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(c-&gt;multibulklen) &#123;</span><br><span class="line">    <span class="comment">// bulklen字段记录当前bulk的长度，为-1时表示未初始化，</span></span><br><span class="line">    <span class="comment">// 需要我们读取当前bulk的第一行进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;bulklen == <span class="number">-1</span>) &#123; </span><br><span class="line">         <span class="comment">// 从qb_pos位置开始，查找querybuf缓冲区中的第一个&#x27;\r&#x27;分隔符。</span></span><br><span class="line">         newline = <span class="built_in">strchr</span>(c-&gt;querybuf+c-&gt;qb_pos,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">         <span class="keyword">if</span> (c-&gt;querybuf[c-&gt;qb_pos] != <span class="string">&#x27;$&#x27;</span>) &#123;...&#125; <span class="comment">// 如果不是以&quot;$&quot;开头，直接抛异常</span></span><br><span class="line">         <span class="comment">// 读取这一行中的数字，也就是该元素的字符串的长度</span></span><br><span class="line">         ok = string2ll(c-&gt;querybuf+c-&gt;qb_pos+<span class="number">1</span>,</span><br><span class="line">                 newline-(c-&gt;querybuf+c-&gt;qb_pos+<span class="number">1</span>),&amp;ll);</span><br><span class="line">        c-&gt;bulklen = ll; <span class="comment">// 字符串长度记录到client-&gt;bulklen字段中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面开始读取字符串的具体内容</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &lt; (<span class="type">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// querybuf缓冲区中数据不足以构造当前元素，</span></span><br><span class="line">        <span class="comment">// 则停止读取，等待连接下次可读事件</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析字符串的具体内容，得到对应的robj对象，并记录到argv数组中。</span></span><br><span class="line">        <span class="comment">// 这里使用的argc字段用来记录请求中元素个数</span></span><br><span class="line">        c-&gt;argv[c-&gt;argc++] =</span><br><span class="line">            createStringObject(c-&gt;querybuf+c-&gt;qb_pos,c-&gt;bulklen);</span><br><span class="line">        c-&gt;argv_len_sum += c-&gt;bulklen; <span class="comment">// 参数长度增加</span></span><br><span class="line">        c-&gt;qb_pos += c-&gt;bulklen+<span class="number">2</span>; <span class="comment">// 后移qb_pos</span></span><br><span class="line">        c-&gt;bulklen = <span class="number">-1</span>; <span class="comment">// 当前字符串读取完毕，重置bulklen</span></span><br><span class="line">        c-&gt;multibulklen--; <span class="comment">// 读完一个元素，multibulklen值递减1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>分析完 processMultibulkBuffer() 解析命令的逻辑之后，我们回到 processInputBuffer() 函数主流程继续往下看，这里循环调用 processMultibulkBuffer() 函数的 while 循环末尾，会有这么一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (io_threads_op != IO_THREADS_OP_IDLE) &#123;</span><br><span class="line">    serverAssert(io_threads_op == IO_THREADS_OP_READ);</span><br><span class="line">    c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为上面CLIENT_PENDING_READ标记为的处理，IO线程中不会执行到这里</span></span><br><span class="line"><span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123; <span class="keyword">return</span>; &#125;</span><br></pre></td></tr></table></figure>


<p>在 IO 线程读取请求的时候，io_threads_op 这个全局变量被设置成了 IO_THREADS_OP_READ，所以 IO 线程能够正常解析请求、不抛异常的时候，一定会走进这个 if 分支里面，这里面就是给 client 添加 CLIENT_PENDING_COMMAND 标志位，它是用来说明这个 client 实例里面已经有解析好的命令，等待主线程进行处理。关键就在这个 break，会直接跳出当前的这个 while 循环，结束当前这条命令的解析过程。</p>
<p>小伙伴们可以 Debug 一下代码，会发现随着这个 while 循环的退出，此次 processInputBuffer()、readQueryFromClient() 函数调用也都会结束，其实这也就是结束了 IO 线程对当前这个 client 上可读事件的处理。</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>分析完命令解析的核心逻辑之后，我们回到 handleClientsWithPendingReadsUsingThreads() 函数，随着 IO 线程以及主线程处理完所有可读的 client 之后，主线程就不再阻塞等待，继续执行下面的逻辑来执行命令。</p>
<p>主线程从阻塞中恢复的第一件事情，就是<strong>把 io_threads_op 这个全局变量改成 IO_THREADS_OP_IDLE 状态，表示 IO 线程全部空闲了</strong>。然后，主线程开始进入一个 while 循环，从 server.clients_pending_read 队列的队头开始弹出 client 实例，每弹出一个 client 元素，就调用一次 processPendingCommandAndInputBuffer() 函数，执行这个 client 里面解析好的命令。</p>
<p>processCommandAndResetClient() 函数底层调用了 processCommand() 和 commandProcessed() 函数，调用栈如下图所示，其中 <strong>processCommand() 函数是命令执行的核心，commandProcessed() 函数是命令执行后的善后处理</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe18a461fe74723988394a630e86ec0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>先来看 processCommand() 函数的核心逻辑。</p>
<ol>
<li>client-&gt;argv[0] 中维护了当前命令的名称，所以我们要做的第一件事就是确定当前处理的是哪条命令。这里会通过 lookupCommand() 函数进行查找，它底层会查找 server.commands 这个命令字典，获取对应的 redisCommand 实例。client-&gt;cmd 字段会记录当前正在执行这个 redisCommand 实例。</li>
</ol>
<!---->

<ol start="2">
<li><p>接下来，对 client-&gt;cmd 进行多项检查检查，如下。</p>
<ul>
<li>检查 client-&gt;cmd 字段是否为空。</li>
<li>检查命令与命令参数是否一致。</li>
<li>检查客户端权限。</li>
<li>检查当前的 Redis Server 是否达到内存上限，达到了之后，就不能继续写入数据了。</li>
<li>如果是 Cluster 模式下运行，会检查命令操作的 key 是否位于当前 Redis 实例上，如果不是，会返回给 Redis 客户端重定向的响应。</li>
<li>如果是在主从模式下运行，还会检查主从复制状态是否正常，如果不正常，就无法写入数据。</li>
<li>还有很多检查，这些检查各有各的目的，这里就不一一列举了。总之，检查不通过时，直接通过 rejectCommandFormat() 函数给客户端返回错误信息。</li>
</ul>
</li>
<li><p>通过上述检查之后，我们就可以开始执行命令了，这里分为两个分支。</p>
<ul>
<li>如果客户端在一个事务上下文中，那么当前命令（特殊命令除外）会入队等待，直至后续有 EXEC 命令到达时，才会将整个队列中的命令一起执行。</li>
<li>要是不在一个事务上下文里面，就会直接调用 call() 函数执行命令。如果当前命令操作了某个客户端阻塞等待的 key，该 key 会添加到 server.ready_keys 列表中，这里会对 ready_keys 进行检查，并调用 handleClientsBlockedOnKeys() 函数唤醒阻塞的客户端。关于阻塞命令的逻辑，我们后面会专门介绍。</li>
</ul>
</li>
</ol>
<p>下面是 processCommand() 函数触发命令执行的核心代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;proc != execCommand ... <span class="comment">// 省略其他不能入队等待执行的命令 ) &#123;</span></span><br><span class="line">    queueMultiCommand(c); <span class="comment">// 将当前命令入队，等待后续执行</span></span><br><span class="line">    addReply(c, shared.queued); <span class="comment">// 给客户端返回&quot;+QUEUED&quot;字符串</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    call(c, CMD_CALL_FULL); <span class="comment">// 调用call()函数执行命令</span></span><br><span class="line">    c-&gt;woff = server.master_repl_offset;</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">        handleClientsBlockedOnKeys(); <span class="comment">// 唤醒阻塞的客户端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 call() 函数中最核心的逻辑就是<strong>调用 client-&gt;cmd-&gt;proc() 函数</strong>，来真正执行命令的处理逻辑，具体执行什么逻辑，就要看具体执行的命令是什么了。比如我们执行 SET 命令，对应的 proc 函数指针指向的就是 setCommand() 函数，其实，我们在 Redis 源码里面看到很多“命令名称 + Command” 结尾的函数，这些都是相应命令的处理逻辑。</p>
<p>除了调用命令的处理逻辑之外，call() 函数中还有很多辅助逻辑和统计操作。</p>
<ul>
<li><p>统计命令执行的时间，如果超过 server.slowlog_log_slower_than 指定的慢查询阈值，会被记录到慢查询日志中。</p>
</li>
<li><p>更新命令对应 redisCommand 实例的各个统计信息。比如，我们执行一条 SET 命令，我们就将所有 SET 命令执行的总耗时（microseconds）、执行的次数（calls）等信息进行累加。同时还会更新 server 相关的统计信息。</p>
</li>
<li><p>根据当前 Redis 实例、命令以及各个客户端的状态，做一些额外的操作。例如，如果当前 Redis 实例是主从模式中的主库或是需要写入 AOF 日志，就需要将带有修改属性的命令传播到从节点或是写入 AOF 文件。</p>
</li>
</ul>
<p>这些额外的操作和统计这里就不再一一展开分析了，在后面介绍别的主题的时候，还会展开介绍。小伙伴在这里只要知道 call() 函数是真正调用 client-&gt;cmd-proc() 函数执行命令的地方即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节中，我们首先介绍了 RESP 2 和 RESP 3 的基础知识，然后介绍了 IO 多线程模式下，Redis 命令解析和命令执行的核心流程。</p>
<p>通过上一节以及本节的学习，你应该可以大致梳理出 <code>Redis 从接收到客户端请求一直到命令执行的整个流程</code>：主线程将发生可读事件的 client 按照 Round Robbin 的方式，分配给多个 IO 线程进行请求读取和命令解析，解析好的命令会放到 client-&gt;argv 这个数组中；等到全部命令解析完之后，主线程才会执行命令，执行命令的核心就是查找 redisCommand 字典，然后调用 client-&gt;cmd-&gt;proc() 函数执行相应的命令逻辑。</p>
<p>在下一节中，我们将开始讲解 Redis 命令执行完成之后的响应是如何返回的。至于 Redis 核心命令的实现逻辑，将在后面的“模块四：命令解析篇” 中进行介绍。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io">Southblock</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC31%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/">https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC31%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hutbzc.github.io" target="_blank">Southblock'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC30%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9ARedis%E8%AF%BB%E5%8F%96%E4%B8%8E%E8%AF%B7%E6%B1%82%E6%A0%B8%E5%BF%83/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC32%E7%AB%A0%E2%80%94%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E7%AF%87%EF%BC%9A%E5%91%BD%E4%BB%A4%E5%93%8D%E5%BA%94%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southblock</div><div class="author-info__description">个人博客Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hutbzc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hutbzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:southblock@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #26da6f;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Southblock' Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RESP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">RESP 协议基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">命令解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC61%E7%AB%A0%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9APub&amp;Sub%E4%B8%8EShardPub&amp;Sub%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC65%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9AGEO%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC68%E7%AB%A0%E2%80%94%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BC%9A%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84Redis%E6%8A%80%E8%83%BD%E6%A0%91%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%99%8B%E5%8D%87%E4%B8%BA%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Southblock</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>