<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Southblock'Blog | Southblock'Blog</title><meta name="author" content="Southblock"><meta name="copyright" content="Southblock"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在前面第 8 讲《 实战应用篇：Hash 命令详解与实战（上）》中我们已经讲解了哈希表的结构，就如下图所示，这个 HashMap 有 8 个槽位，每个槽位下面挂一个链表。我们这一节就来看看 Redis 里面哈希表是怎么实现的。  在 Redis 里面，Hash 表底层依赖的数据结构其实有两种：第一种是前面介绍的 ziplist，Redis 7.0 之后呢，就是 listpack，总之就是一块连续的">
<meta property="og:type" content="article">
<meta property="og:title" content="Southblock&#39;Blog">
<meta property="og:url" content="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC20%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5Hash%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Southblock&#39;Blog">
<meta property="og:description" content="在前面第 8 讲《 实战应用篇：Hash 命令详解与实战（上）》中我们已经讲解了哈希表的结构，就如下图所示，这个 HashMap 有 8 个槽位，每个槽位下面挂一个链表。我们这一节就来看看 Redis 里面哈希表是怎么实现的。  在 Redis 里面，Hash 表底层依赖的数据结构其实有两种：第一种是前面介绍的 ziplist，Redis 7.0 之后呢，就是 listpack，总之就是一块连续的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg">
<meta property="article:published_time" content="2026-02-05T16:27:41.303Z">
<meta property="article:modified_time" content="2026-02-05T16:27:41.303Z">
<meta property="article:author" content="Southblock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC20%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5Hash%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Southblock\'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-06 00:27:41'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Southblock'Blog"><span class="site-name">Southblock'Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-05T16:27:41.303Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-05T16:27:41.303Z" title="更新于 2026-02-06 00:27:41">2026-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在前面第 8 讲<a target="_blank" rel="noopener" href="https://juejin.cn/book/7144917657089736743/section/7147528669831905315">《 实战应用篇：Hash 命令详解与实战（上）》</a>中我们已经讲解了哈希表的结构，就如下图所示，这个 HashMap 有 8 个槽位，每个槽位下面挂一个链表。我们这一节就来看看 Redis 里面哈希表是怎么实现的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df20f98bba79481fb521c5b4715b8ff8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在 Redis 里面，Hash 表底层依赖的数据结构其实有<code>两种</code>：第一种是前面介绍的 ziplist，Redis 7.0 之后呢，就是 listpack，总之就是一块连续的内存空间；另一种是我们今天这一节要介绍的 dict 结构，它就是哈希表的结构。</p>
<p>在后面介绍 redisObject 对象的时候，我们还会展开说明哈希表底层什么时候用 listpack、什么时候用 dict，现在你只需要知道：<strong>哈希表底层数据少、键值对都比较短的时候用 listpack 存，数据量大了之后就用 dict 存</strong>。</p>
<h2 id="dict-dictEntry"><a href="#dict-dictEntry" class="headerlink" title="dict &amp; dictEntry"></a>dict &amp; dictEntry</h2><p>在 Redis 里面，哈希表对应的是 dict 这个结构体，你看其他 Redis 文章的时候，说到的字典结构，其实就是这个结构体。</p>
<p>我们打开 dict.h 这个头文件，找到字典这个结构体的定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    ... ... </span><br><span class="line">    <span class="comment">// 真正存储数据的地方，里面有两个哈希表</span></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面最关键的就是 <code>ht_table</code> 这个数组，这个数组里面放了两个 dictEntry 的二级指针，二级指针在前面第 3 讲<a target="_blank" rel="noopener" href="https://juejin.cn/book/7144917657089736743/section/7147527076092837888">《先导基础篇：10 分钟 C 语言入门》</a>也说过，是指向指针的指针。</p>
<p>如下图，这两个二级指针，分别指向了一个哈希表或者说是哈希 table。再展开看每个哈希 table 的结构，这个二级指针实际上指向的是一个 dictEntry 指针的数组，就是图中绿底的数组，里面每个元素都是 dictEntry 指针；然后这些 dictEntry 指针，指向了一个 dictEntry 列表，就是图中紫色底的列表。我用虚线框出来的这个部分，与上文介绍的哈希表结构非常类似了。（至于为什么 ht_table 里面要放两个 dicEntry** 二级指针，然后指向两个不同的哈希 table，我们后面会展开说。）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d258c1c83ca4834a8f8efc96cacf9c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>我们先来看看 <code>dictEntry </code>这个结构体，如下所示，它表示的是字典中的一个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">// 键值对中的Key，实际上指向一个sds实例</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> <span class="comment">// 用来存储键值对中的value值，因为是一个union，所以下面四个字段</span></span><br><span class="line">            <span class="comment">// 同时只会有一个有值</span></span><br><span class="line">        <span class="type">void</span> *val;     <span class="comment">// 当value是一个非数字类型的值时，使用该指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64; <span class="comment">// 当value值是一个无符号整数时，使用u64字段进行存储</span></span><br><span class="line">        <span class="type">int64_t</span> s64;  <span class="comment">// 当value值是一个有符号整数时，使用s64字段进行存储</span></span><br><span class="line">        <span class="type">double</span> d;     <span class="comment">// 当value值是一个浮点数时，使用d字段进行存储</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="type">void</span> *metadata[];  <span class="comment">// 额外的空间，这个跟Redis Cluster相关，后面再说</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>我们解释下这其中的各个字段的含义。</p>
<ul>
<li>key 指针存储的是键值对中的 Key，其实就是指向了一个 sds 实例。</li>
</ul>
<!---->

<ul>
<li>v 字段表示的是键值对的 Value 值，它有点特殊，是一个 union，也就是联合体。联合体里面有 4 个字段，但是只有一个字段能有值。如果 Value 值是一个非数字的类型，就用 val 这个指针来存；如果 Value 是一个数字，还要分成无符号、有符号和浮点数三种情况，对应地就是用 u64、s64、d 三个字段存。</li>
</ul>
<!---->

<ul>
<li>next 字段是指向下一个节点的指针。每个哈希槽里面存储的都是一个链表，每个链表节点都是通过这个 next 指针连接下一个节点的。</li>
</ul>
<!---->

<ul>
<li>至于 metadata 字段，是和 Redis Cluster 相关的一个优化，这里先不展开说，柔性数组，也不占空间。</li>
</ul>
<p>分析完 dictEntry 结构体的事情之后，我们再继续回来看 <code>dict 结构体</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前dict实例使用的一些特殊函数集合，通过这些函数可以改变当前dict的行为</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 真正存储数据的hashtable，其中一个是在rehash的时候使用，实现渐进式的rehash</span></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 每个哈希table里面存了多少个元素</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 渐进式rehash现在处理的哈希槽索引值</span></span><br><span class="line">    <span class="type">long</span> rehashidx; </span><br><span class="line">    <span class="comment">// 用来暂停渐进式rehash的开关</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;</span><br><span class="line">    <span class="comment">// 记录两个哈希table的长度，实际是是记录2的n次方中的 n 这个值</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ht_table 这个数组里面记录了两个哈希 table 里面存了多少个元素，然后 ht_size_exp 里面存了两个哈希 table 中数组的长度，也就是哈希槽的个数，读过 HashMap 的小伙伴应该知道，这个数组每次扩容都是两倍两倍地扩，这里也是一样，所以 ht_size_exp 里面记的实际上就是 2 的 n 次方里面的这个 n。</p>
<p>rehashidx 字段是一个指向哈希槽的下标值，这个在后面讲解<code>渐进式 rehash</code> 的时候，会看到这个字段的用处。pauserehash 字段是类似锁的功能，锁重入一次，pauserehash 就会加一次 1；锁退出一次，就减一次 1。那这个字段用来锁什么的呢？是用来锁渐进式 rehash，锁上了，渐进式 rehash 就停了，这个后面说哈，大概知道是干啥的就行了。</p>
<p>好了，dict 结构体的核心部分我们就说完了，你应该都懂了吧，不懂的地方，评论区说一下哈。</p>
<h2 id="dictType"><a href="#dictType" class="headerlink" title="dictType"></a>dictType</h2><p>dict 结构体里面还有一个 type 指针，它指向了一个 dictType 对象。看名字就知道，它表示的就是 dict 的类型。看到这里，估计你会很纳闷：哈希表还有类型？</p>
<p>所以，我们就一起来看下 dictType 到底是个什么东西。</p>
<h3 id="1-dictType-定义解析"><a href="#1-dictType-定义解析" class="headerlink" title="1. dictType 定义解析"></a>1. dictType 定义解析</h3><p>首先，来看 dictType 这个结构体，这里面就是<strong>一批函数指针的集合，这些指针指向的函数决定了 dict 实例的一些关键行为</strong>。dictType 结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// hashFunction函数用来计算key的hash值</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// keyDup和valDup分别负责对key和value进行复制</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 用来比较两个key是否相同</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// keyDestructor和valDestructor分别负责销毁key和value </span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 用来检查当前dict是否需要扩容 </span></span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">// 用来计算metadata那个柔性数组的长度，用来检查</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>


<p>可以看到：hashFunction 指向的这个函数是用来计算 key 的 hash 值；然后下面这两个函数，结尾都是 Dup（其实就是 Duplicate 的缩写）。有的时候，往一个 dict 里面存一个 Value 的时候，是希望这个 Value 值被独占的，也就是别的地方修改了 Value 值，但是不会影响已经写入到 dict 里的 Value，这个时候怎么办呢？是不是就需要在存 Value 的时候，<strong>深拷贝</strong>一份就行了？这样两个 Value 就是不同的对象了。这个时候就要用 valDup 这个函数来进行深拷贝了，keyDup 也是一样的功能。</p>
<p>写入的时候深拷贝了，那再释放的时候，就需要把这些拷贝出来的内存释放掉。这就需要用后面的 keyDestructor 和 valDestructor 两个函数，一个用来释放 Key，一个用来释放 Value 值。</p>
<p>至于 keyCompare 函数，就和我们 Java 里面 Comparator 接口类似，用来比较两个 Key 是否相等；expandAllowed 函数则是用来检查这个哈希表能不能扩容。</p>
<h3 id="2-dictType-核心实现分析"><a href="#2-dictType-核心实现分析" class="headerlink" title="2. dictType 核心实现分析"></a>2. dictType 核心实现分析</h3><p>dictType 这种定义一堆函数指针的方式，有点像 Java 里面的接口，这些函数指针类似于接口中的方法签名。我们来看 server.c 这个文件，里面搜 dictType，可以看非常多的 dictType 实现，如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c39bf82bfb4c5098a6f9fb1d0c2be7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这里我们选取 dbDictType、hashDictType 和 setDictType 这三个<code>比较典型、比较重点</code>的实现进行分析。</p>
<p><strong>dictType 的第一个典型实现是：dbDictType</strong>。Redis 本身是一个 KV 数据库，其实 Redis DB 也就是一个大的哈希表，只不过 Value 可能是 String、List、哈希表这种复杂结构而已。没错，dbDictType 就是 Redis 存全部键值对的哈希表使用的 dictType 实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dictType dbDictType = &#123; </span><br><span class="line">    dictSdsHash,   <span class="comment">// dictSdsHash函数底层就是使用siphash算法 </span></span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// keyDup和valDup两个指针为NULL，表示不会对键值对进行复制 </span></span><br><span class="line">    <span class="literal">NULL</span>,  </span><br><span class="line">    dictSdsKeyCompare, <span class="comment">// key按照字符串方式进行比较 </span></span><br><span class="line">    dictSdsDestructor, <span class="comment">// key按照字符串方式进行销毁 </span></span><br><span class="line">    <span class="comment">// Redis中每个value值都是robj类型，所以value按照robj类型进行销毁 </span></span><br><span class="line">    dictObjectDestructor,  </span><br><span class="line">    dictExpandAllowed <span class="comment">// 通过dictExpandAllowed函数决定是否扩容 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>先看 dictSdsHash 这个哈希函数，名字就告诉我们了，它是给 sds 算 hash 值的。我们看一下调用链，如下图能看到它底层使用的是 siphash 这个哈希算法。哈希算法一般是朝着两个方向发展，一个是提高哈希速度，一个是减少碰撞次数。siphash 这个算法比较有意思，它主要是来解决哈希洪水攻击这种安全问题的，计算 hash 值的速度以及 hash 碰撞次数也都比较优秀，现在也被很多语言内置。</p>
<blockquote>
<p>想深挖哈希洪水攻击和 siphash 算法的小伙伴，可以看<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/286529973">这篇文章</a>入个门，这篇文章里面还说从攻击角度来看，Java 里面哈希桶超过 8 个元素就转成平衡树的一些思考，挺有意思的。</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/291a9dad1d714d6ca1afa1aacb965496~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>我们回到 dbDictType 这个实现继续看，它里面的 keyDup 和 valDup 两个指针都是 NULL 值，那就是说，不对 key 和 value 进行深拷贝，传进什么实例就用什么实例了。</p>
<p>再往下看，Key 的比较就是比较两个 sds 的值，来看代码，如下所示，其实就是先比较 sds 长度，然后用 memcmp 比较 sds 里面的每个字节，这个没什么难理解的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictSdsKeyCompare</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key1,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *key2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1,l2;</span><br><span class="line">    UNUSED(d);</span><br><span class="line"></span><br><span class="line">    l1 = sdslen((sds)key1);</span><br><span class="line">    l2 = sdslen((sds)key2);</span><br><span class="line">    <span class="keyword">if</span> (l1 != l2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(key1, key2, l1) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个 key 的销毁函数 dictSdsDestructor()，猜也猜的到，就是释放 sds，代码如下所示，果然就是直接调用 sdsfree 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictSdsDestructor</span><span class="params">(dict *d, <span class="type">void</span> *val)</span>&#123;</span><br><span class="line">    sdsfree(val); <span class="comment">// 释放sds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但销毁 value 的 dictObjectDestructor 函数就有点不一样，Redis 里面的 Value 可能是字符串，也可能是 List 或者哈希表，那我们调用哪种对象的销毁函数呢？Redis 在这些数据类型外面，又包了一层叫 robj 的结构体（全称就是 redis Object），它里面有个指针，指向了真正的字符串、List 之类的数据类型；另外，redis Object 里面还有个引用计数器，要是引用数掉到 1 了，就释放这个对象，是不是有点熟悉的味道呢？引用计数版本的垃圾回收器即将脱口而出。</p>
<p>我们回到 dbDictType，来看其中 dictObjectDestructor() 函数的实现，它释放 value 的逻辑就是减 redis Object 的引用计数器，我们点进去看，现在是 1 了，只有一个引用了，还要再减，就是 0 了，没人引用了，就根据里面存的具体类型，调释放函数回收内存，字符串调 sdsfree，List 调用 quicklistRelease，一个个节点释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictObjectDestructor</span><span class="params">(dict *d, <span class="type">void</span> *val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span>; </span><br><span class="line">    decrRefCount(val); <span class="comment">// 引用次数减1，减到0就会释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrRefCount</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123; <span class="comment">// 无无人引用的时候，会调用value对应的free函数进行释放</span></span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">&quot;Unknown object type&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">&quot;decrRefCount against refcount &lt;= 0&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后，就是扩容函数 dictExpandAllowed() ，它的扩容逻辑就是看使用率是不是超过了 1.618，然后看看要是再扩容的话，是不是到了内存上限值，到了上限，肯定是不能扩容了。检查都通过 ，就会返回 1，允许扩容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictExpandAllowed</span><span class="params">(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (usedRatio &lt;= <span class="number">1.618</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !overMaxmemoryAfterAlloc(moreMem); <span class="comment">// 扩容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbDictType 说完之后，你是不是感觉对 Redis DB 的一些关键行为，又多了些了解呢？</p>
<p><strong>dictType 的第二个典型实现是 hashDictType</strong>。 hashDictType 是 Redis 里面 Hash 这种数据类型使用的 dictType 实现，具体定义如下所示。它里面的 hash 函数也是用的 siphash 算法，在写入键值对的时候不会进行复制，它使用的 Key 比较函数，也是 sds 字符串的比较。Redis Hash 结构中，键值对都只能是字符串，所以销毁 Key 和 Value 的函数，都是销毁 sds 字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dictType hashDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">// dictSdsHash函数底层就是使用siphash算法 </span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">// keyDup和valDup两个指针为NULL，表示不会对键值对进行复制</span></span><br><span class="line">    <span class="literal">NULL</span>,                       </span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">// 按照sds来比较Key</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">// 按照sds来销毁Key</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">// 按照sds来销毁Key</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">// 默认允许扩容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>dictType 的第三个典型实现是 setDictType 实现</strong>。它是 Set 这个数据类型对应的 dictType 实现。这里你可以先回忆一下 Java 里面 HashSet 的实现，底层其实是一个 HashMap，Key 用来存储 Set 的元素，Value 里面存一个固定的对象。Redis 里面也是类似的实现，Set 也是依赖 dict 实现的，Set 底层的 dict 中，Value 部分为空，也就无需进行比较、销毁等操作。</p>
<p>我们来看 setDictType 的实现，这里面需要我们关注的是 Value 销毁的函数，是个 NULL，也就是无需销毁 Value，与我们预想的一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dictType setDictType = &#123;</span><br><span class="line">    dictSdsHash,   <span class="comment">// dictSdsHash函数底层就是使用siphash算法 </span></span><br><span class="line">    <span class="literal">NULL</span>,          <span class="comment">// keyDup和valDup两个指针为NULL，表示不会对键值对进行复制</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// set集合中只能存放字符串的key，所以比较函数和销毁函数按照字符串方式进行处理</span></span><br><span class="line">    dictSdsKeyCompare, </span><br><span class="line">    dictSdsDestructor, </span><br><span class="line">    <span class="literal">NULL</span>            <span class="comment">// set集合是没有使用到value的，所以不需要对应的销毁函数</span></span><br><span class="line">                    <span class="comment">// 未指定expandAllowed函数，默认支持扩容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>最后，看一下 setDictType 和 hashDictType 里面的扩容函数，都是 NULL，NULL 的意思就是允许扩容，不做任何限制。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节中，我们重点介绍了 <strong>Redis 里面哈希表的核心结构体，它与我们 Java 里面 HashMap 的实现非常相似</strong>。在 dict 结构体中，最关键的就是 <code>ht_table</code> 这个数组，这个数组里面放了两个 dictEntry 的二级指针，我们这里还详细分析了 dictEntry 的结构。</p>
<p>接下来讲解了 dictType 这个类似接口的结构体，它定义了 dict 中的几个关键行为，例如，如何复制写入的键值对、如何比较键值对、如何销毁键值对、以及扩容的判断条件。最后，介绍了 dictType 最重要、最典型的三个实现。</p>
<p>另外，本节还挖了很多“坑”，比如：rehashidx 字段是干啥的？渐进式 rehash 是什么操作呢？这些“坑”我们在下一节就填哦。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io">Southblock</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC20%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5Hash%E5%AE%9E%E7%8E%B0/">https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC20%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5Hash%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hutbzc.github.io" target="_blank">Southblock'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5quicklist%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC21%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9AHash%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southblock</div><div class="author-info__description">个人博客Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hutbzc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hutbzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:southblock@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #26da6f;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Southblock' Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#dict-dictEntry"><span class="toc-number">1.</span> <span class="toc-text">dict &amp; dictEntry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dictType"><span class="toc-number">2.</span> <span class="toc-text">dictType</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-dictType-%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">1. dictType 定义解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-dictType-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2. dictType 核心实现分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC61%E7%AB%A0%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AF%87%EF%BC%9APub&amp;Sub%E4%B8%8EShardPub&amp;Sub%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC65%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9AGEO%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC68%E7%AB%A0%E2%80%94%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BC%9A%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84Redis%E6%8A%80%E8%83%BD%E6%A0%91%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%99%8B%E5%8D%87%E4%B8%BA%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B/" title="无题">无题</a><time datetime="2026-02-05T16:27:41.308Z" title="发表于 2026-02-06 00:27:41">2026-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Southblock</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>