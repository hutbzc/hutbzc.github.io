<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Southblock'Blog | Southblock'Blog</title><meta name="author" content="Southblock"><meta name="copyright" content="Southblock"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在上一讲中，我们重点介绍了 quicklist 的核心结构，一起分析了 quicklist 里面关键的结构体定义以及关键的配置含义。本节我们将继续重点介绍 quicklist 的核心函数，主要包括：插入数据、弹出数据以及查询数据这三方面的函数实现。 创建 quicklist首先来看创建 quicklist 实例的 quicklistNew() 函数，可以用 CLoin 调用链的视图看一下它都调了哪">
<meta property="og:type" content="article">
<meta property="og:title" content="Southblock&#39;Blog">
<meta property="og:url" content="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5quicklist%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="Southblock&#39;Blog">
<meta property="og:description" content="在上一讲中，我们重点介绍了 quicklist 的核心结构，一起分析了 quicklist 里面关键的结构体定义以及关键的配置含义。本节我们将继续重点介绍 quicklist 的核心函数，主要包括：插入数据、弹出数据以及查询数据这三方面的函数实现。 创建 quicklist首先来看创建 quicklist 实例的 quicklistNew() 函数，可以用 CLoin 调用链的视图看一下它都调了哪">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg">
<meta property="article:published_time" content="2026-02-05T16:11:32.423Z">
<meta property="article:modified_time" content="2026-02-05T16:11:32.423Z">
<meta property="article:author" content="Southblock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5quicklist%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Southblock\'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-06 00:11:32'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Southblock'Blog"><span class="site-name">Southblock'Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-05T16:11:32.423Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-05T16:11:32.423Z" title="更新于 2026-02-06 00:11:32">2026-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一讲中，我们重点介绍了 quicklist 的核心结构，一起分析了 quicklist 里面关键的结构体定义以及关键的配置含义。本节我们将继续重点介绍 quicklist 的核心函数，主要包括：<code>插入数据</code>、<code>弹出数据</code>以及<code>查询数据</code>这三方面的函数实现。</p>
<h2 id="创建-quicklist"><a href="#创建-quicklist" class="headerlink" title="创建 quicklist"></a>创建 quicklist</h2><p>首先来看创建 quicklist 实例的 <code>quicklistNew() 函数</code>，可以用 CLoin 调用链的视图看一下它都调了哪些函数。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13f74fdfca8441f1be8cc5756b55e10c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>可以看到，quicklistNew() 函数先会调用 quicklistCreate() 创建一个空 quicklist 实例，里面就是走 malloc 分配内存，然后通过 quicklistSetCompressDeth() 和 quicklistSetFill() 函数来初始化 compress 和 fill 两个字段。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>向 quicklist 插入一个元素的入口函数是 <code>quicklistPush() 函数</code>，其核心代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123; <span class="comment">// 在头部插入数据</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123; <span class="comment">// 在尾部插入数据</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到其中有一个 if 条件判断，这个 where 参数决定了是从 quicklist 的头部添加数据，还是从 quicklist 的尾部添加数据，也就进入了 pushHead 和 pushTail 两个分支。</p>
<p>从下面的调用关系链截图，也能看到，quicklistPush 调用了 quicklistPushHead 和 quicklistPushTail 两个分支。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088a90192d59431882df4b7bc4af3330~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>下面我们就拿 quicklistPushHead 这个分支为例进行分析（quicklistPushTail 这个分支，在代码实现上和 quicklistPushHead 的差异不大，这里就不再赘述），相关实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(isLargeElement(sz))) &#123; <span class="comment">// 不太可能执行到的分支，碰到超过1G元素</span></span><br><span class="line">        __quicklistInsertPlainNode(quicklist, quicklist-&gt;head, value, sz, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely( <span class="comment">// 可能执行到的分支，正常元素</span></span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;entry = lpPrepend(quicklist-&gt;head-&gt;entry, value, sz);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 初始化一个新quicklistNode</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;entry = lpPrepend(lpNew(<span class="number">0</span>), value, sz);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 quicklistPushHead() 里面有<strong>三个核心分支</strong>：</p>
<ul>
<li><p>第一个分支是专门处理超过 1G 的大元素；</p>
</li>
<li><p>第二个分支是正常插入元素，在这个分支中，直接调用了 listpack 的 lpPrepend 函数向头节点的 listpack 里面写入新元素；</p>
</li>
<li><p>最后一个是 else 分支用来处理 quicklistNode 分裂的场景，大概意思是头节点里面 listpack 的长度达到了 list-max-listpack-size 指定的上限，需要重新初始化一个 quicklistNode。</p>
</li>
</ul>
<h3 id="1-likely-与-unlikely"><a href="#1-likely-与-unlikely" class="headerlink" title="1. likely 与 unlikely"></a>1. likely 与 unlikely</h3><p>在开始展开分析 quicklistPushHead 中每个分支的具体实现之前，我们需要先介绍一下在这些分支判断条件中使用的 <code>unlikely 和 likely 这两个宏</code>，分别对应的是这两个 bulltin 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>要理解这两个函数，得需要一些 <code>CPU 流水线</code>的基础知识，这里我简单介绍一下，如果小伙伴了解这部分基础知识，可以直接跳过。</p>
<p>CPU 执行命令之前需要读指令、解析指令，然后才能真正执行指令，其中读指令的时间比较久，串行的话，CPU 就要等待执行从各级缓存或内存加载到寄存器里面，比如说下面这张图，白色块占的时间，都是 CPU 空闲等待的时间。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad45fb6f34349769cd94015027ff28f~tplv-k3u1fbpfcp-watermark.image" alt="19 CPU流水线1.jpg"></p>
<p>为了打满 CPU 呢，就可以用<code>预取指令</code>的方式，提前给 CPU 准备好下一条指令。如下图所示，CPU 就一直在执行指令了。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb10831f7ae4001be8d93e77d46ebd5~tplv-k3u1fbpfcp-watermark.image" alt="19 CPU 流水线2.jpg"></p>
<p>需要注意一个问题，<strong>预取指令的数量是有限的</strong>。比如说，CPU 只能预取后面 10 条、20 条指令，不可能把整个程序的指令都预取进来，CPU 高速缓存之类的地方是存不下的。</p>
<p>那我们要预取哪些指令呢？正常情况下，就按照我们代码书写的顺序进行预取，是不是就行了？</p>
<p>但是，我们的代码里面会有非常多的 if…else 这种跳转语句，顺序预取的方式就会失败，因为计算机不知道要预取 if 的分支，还是 else 的分支。这个时候，<strong>我们就可以用 builtin 函数告诉计算机：走这个分支的概率很大，让 CPU 优先考虑来预取这个分支的代码</strong>。一旦落到这个分支里面的话，就命中了预取的代码，实现效率的提升。</p>
<h3 id="2-插入大元素"><a href="#2-插入大元素" class="headerlink" title="2. 插入大元素"></a>2. 插入大元素</h3><p>我们回到 quicklistPushHead 的代码，继续分析。</p>
<p>第一个分支，这个里面的判断条件就是元素是否超过了 1G，1G 以上的这种超大元素不太可能经常出现，所以用了 unlikely 这个判断条件。</p>
<p>虽然不太经常出现，但我们还是要去看看它的处理逻辑，这里面走的 CreatePlainNode 函数，实际上就是新建了一个 quicklistNode 节点，里面的 entry 指针指向了这个超大的元素，这里的 container 字段也设置成了 PLAIN（你可以回顾一下上一讲中，对 container 两个可选值 PLAIN 和 PACKED 的介绍）。</p>
<p>然后，这个 __quicklistInsertNode() 函数会将新建的 quicklistNode 节点插入到 quicklist 里面，这个添加过程就是链表加节点的指针操作，就不多说了。最后，还有一个压缩函数节点的操作，你可以暂时先把这个地方当作黑盒，在本节后续会有专门的部分详细展开介绍。</p>
<h3 id="3-插入正常元素"><a href="#3-插入正常元素" class="headerlink" title="3. 插入正常元素"></a>3. 插入正常元素</h3><p>再来看 quicklistPushHead() 核心逻辑中插入正常元素的分支，这个分支的判断条件会检查头部节点的 listpack 能不能继续写入新 element。</p>
<p>下面来简单分析一下检查逻辑，具体位于 <code>_quicklistNodeAllowInsert() 函数</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="type">int</span> _quicklistNodeAllowInsert(<span class="type">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="type">const</span> <span class="type">int</span> fill, <span class="type">const</span> <span class="type">size_t</span> sz) &#123;</span><br><span class="line">    ... <span class="comment">// 省略非关键代码</span></span><br><span class="line">    <span class="comment">// 第一个if分支，检查该节点是否为PLAIN类型节点</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="type">size_t</span> new_sz = node-&gt;sz + sz + SIZE_ESTIMATE_OVERHEAD;</span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill))) <span class="comment">// fill为负数时的检查分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz)) <span class="comment">// fill为正数的检查分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">int</span>)node-&gt;count &lt; fill)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 _quicklistNodeAllowInsert() 中第一个 if 分支，是看 quicklistNode 是不是 PLAIN 类型，如果是的话，这个 quicklistNode 是被独占的，不能往里加别的元素。</p>
<p>再往下，_quicklistNodeAllowInsert() 函数就要开始预估一下插入新元素之后，这个 listpack 状态了。下面的 _quicklistNodeSizeMeetsOptimizationRequirement() 分支是在 listpack-size 取 -1、-2 之类的这种负数的时候有效，你可以进入该方法看一下，会看到 fill 大于 0 的时候，直接就 return 0 了；如果 fill 是负数的时候，才会根据 fill 值确定对应的 listpack 长度上限值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="type">int</span></span><br><span class="line">_quicklistNodeSizeMeetsOptimizationRequirement(<span class="type">const</span> <span class="type">size_t</span> sz,</span><br><span class="line">                                               <span class="type">const</span> <span class="type">int</span> fill) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fill &gt;= <span class="number">0</span>) <span class="comment">//  listpack-size位置为正，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> offset = (-fill) - <span class="number">1</span>; <span class="comment">//  listpack-size为负，才会确定listpack的长度上限值</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; (<span class="keyword">sizeof</span>(optimization_level) / <span class="keyword">sizeof</span>(*optimization_level))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= optimization_level[offset]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要是 listpack-size 配置是正数，表示的是元素个数上限。这里会先通过 sizeMeetsSafetyLimit() 检查一下 listpack 字节长度，最长不能超过 8k，然后再去检查元素个数，保证元素个数不能超过 listpack-size 配置。8k 和元素个数任何一个不满足条件，都不能继续插入新元素了。</p>
<h3 id="4-节点分裂场景处理"><a href="#4-节点分裂场景处理" class="headerlink" title="4. 节点分裂场景处理"></a>4. 节点分裂场景处理</h3><p>quicklistPushHead() 里面最后一个分支，用于处理节点分裂的情况，也就是一个 quicklistNode 节点达到存储上限之后，需要新建 quicklistNode 头节点来存储新插入的元素。</p>
<p>看该分支的代码，就可以清晰地了解其逻辑就是创建一个 PACKED 类型的 quicklistNode 节点，作为 quicklist 的头节点，然后新元素再写到它的 listpack 里面。这个分支里面的逻辑比较简单，但是可能会触发原节点的压缩，下面会单独进行分析。</p>
<p>新元素插入完成之后，quicklistPushHead() 函数会更新一下 quicklistNode 和 quicklist 的统计信息，就完成整个插入操作了。</p>
<h2 id="节点压缩逻辑"><a href="#节点压缩逻辑" class="headerlink" title="节点压缩逻辑"></a>节点压缩逻辑</h2><p>我们前面埋了一个坑，在有新 quicklistNode 插入到 quicklist 的时候，是可能会触发压缩的，这件事我们没展开说，现在解释一下。</p>
<p>先举个例子，假设我们的 compress-depth 配置成了 1，那就是下图的状态，只有首尾的两个节点的 listpack 没有被压缩。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bff29f0efa0412b99292a7232ffb50d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>现在在头部插入一个新 quicklistNode 节点，此时我们就需要把原来的头部节点进行压缩，就是这个图里面标红的 quicklistNode 节点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30eee0fac19b41c8bf5dc077ef1cef8a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>触发压缩的例子说明了之后，我们再来看 quicklistCompress 这个宏，它分了两个分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> quicklistCompress(_ql, _node)                                          </span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       </span><br><span class="line">        <span class="keyword">if</span> ((_node)-&gt;recompress) <span class="comment">// 重新压缩   </span></span><br><span class="line">            quicklistCompressNode((_node));    </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 第一次压缩</span></span><br><span class="line">            __quicklistCompress((_ql), (_node));                               </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>先说第一个分支的用处，在用迭代器迭代 quicklist 的时候，需要把各个节点先解压，然后才能迭代里面的元素，在这个解压的时候，就会设置 recompress 标志。迭代完了，就会执行这里的第一个分支，把节点再压缩起来。</p>
<p>插入新 quicklistNode 的场景显然是走第二个分支，我们看下这个 <code>__quicklistCompress() 函数</code>。在该函数的开头都是在检查这个 quicklist 是不是需要压缩，比如 compress-depth 配置成了 0 或者是 quicklistNode 节点数非常少，都不用压缩了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="type">void</span> __quicklistCompress(<span class="type">const</span> quicklist *quicklist,</span><br><span class="line">                                      quicklistNode *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    assert(quicklist-&gt;head-&gt;recompress == <span class="number">0</span> &amp;&amp; quicklist-&gt;tail-&gt;recompress == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 判断quicklist是不是需要进行压缩</span></span><br><span class="line">    <span class="keyword">if</span> (!quicklistAllowsCompression(quicklist) ||</span><br><span class="line">        quicklist-&gt;len &lt; (<span class="type">unsigned</span> <span class="type">int</span>)(quicklist-&gt;compress * <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    quicklistNode *forward = quicklist-&gt;head;</span><br><span class="line">    quicklistNode *reverse = quicklist-&gt;tail;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> in_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth++ &lt; quicklist-&gt;compress) &#123; <span class="comment">// 该循环同时从quicklist两端开始，向中间节点开始检查</span></span><br><span class="line">        quicklistDecompressNode(forward);</span><br><span class="line">        quicklistDecompressNode(reverse);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == node || reverse == node)</span><br><span class="line">            in_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == reverse || forward-&gt;next == reverse)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        forward = forward-&gt;next;</span><br><span class="line">        reverse = reverse-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_depth) <span class="comment">// 要压缩的目标节点位于压缩区域，才能执行压缩</span></span><br><span class="line">        quicklistCompressNode(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩forward和reverse两个节点</span></span><br><span class="line">    quicklistCompressNode(forward);</span><br><span class="line">    quicklistCompressNode(reverse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__quicklistCompress() 函数中最核心的就是上述代码片段中的 while 循环，它会同时从 quicklist 的两端开始往中间节点检查。比如说，现在 compress-depth 是 3，那首尾三个节点都要是不压缩的状态，这个 while 循环就会循环 3 次，forward、reverse 两个指针的移动方向，就是下面这张图，循环到的这 6 个节点都会被解压，解压的逻辑是 Decompress 这个宏里面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8172933488a495f90de91d67ed7a15a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>处理完 quicklist 两端的压缩的事情之后呢，我们来关注 __quicklistCompress() 函数的最后一个 node 参数，这个参数传入的是此次要压缩的目标节点。如果这个节点在上述非压缩范围内，就无需压缩了；如果在压缩范围内，则需要执行 quicklistCompressNode() 函数进行压缩处理。</p>
<p>继续往下看，在上面 while 循环结束的时候，forward、reverse 两个指针已经离开了非压缩区域，这里会顺带将 forward、reverse 两个节点压缩掉。</p>
<p>举个例子，来看下面这张图，compress-depth 还是 3，节点从 6 个增长到 7 个节点的时候，forward、reverse 指针在 while 循环结束的时候，都会指向中间这个节点，已经离开了非压缩区域，需要把它压缩掉；然后继续往 quicklist 头部插入节点，节点增长到 8 个的时候，forward、reverse 指向中间两个节点，reverse 已经压缩过了，forward 需要压缩；节点继续增长到 9 个的时候，forward 需要压缩，最中间的节点、还有 reverse 节点在节点是 8 的时候，已经压缩过了，就不用管了。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ec7fbba8084a70896db1a87456e639~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>到此为止，从 quicklist 头部插入新元素的事情，已经说完了。从尾部插入的逻辑就不再重复了，相信小伙伴们看这部分的代码应该会非常轻松。</p>
<h2 id="指定位置插入数据"><a href="#指定位置插入数据" class="headerlink" title="指定位置插入数据"></a>指定位置插入数据</h2><p>除了从头尾插入数据之外，quicklist 还可以<strong>在指定的位置插入数据</strong>，具体就是 <code>InsertAfter()</code> 和 <code>InsertBefore()</code> 这两个函数。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1cdbc45e2147609eb739f67a95fd08~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>从名字上就能看出来，After 是在指定位置之后插入数据，Before 是在前面插入。这两个函数，底层都依赖了<code> _quicklistInsert() </code>，来看一眼调用关系：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b1726f45fc84eafa97aac84ca86122c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这里我们就拿 InsertAfter() 的场景为例来讲解 __quicklistInsert() 函数的实现。</p>
<p>先说一下这个 __quicklistInsert() 函数的参数，第一个是一个 quicklist 迭代器，第二个 entry 参数是用来定位插入位置的。比如，我们执行一条 LINSERT AFTER 命令，就是先用一个 quicklist 迭代器，从头到尾迭代 List 查找锚点元素，找到之后就在这个锚点元素后面，插入新元素，这个迭代器就是第一个参数，锚点元素的位置就记到了第二个参数里面。后面两个参数，就是插入的新元素值。</p>
<p>说明白参数的含义之后，就要开始分析定点插入的实现了，先来看第一部分代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="type">void</span> _quicklistInsert(quicklistIter *iter, quicklistEntry *entry,</span><br><span class="line">                                   <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz, <span class="type">int</span> after)</span><br><span class="line">&#123;</span><br><span class="line">    quicklist *quicklist = iter-&gt;quicklist;</span><br><span class="line">    <span class="comment">// 定义一些控制变量</span></span><br><span class="line">    <span class="type">int</span> full = <span class="number">0</span>, at_tail = <span class="number">0</span>, at_head = <span class="number">0</span>, avail_next = <span class="number">0</span>, avail_prev = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fill = quicklist-&gt;fill;</span><br><span class="line">    quicklistNode *node = entry-&gt;node;</span><br><span class="line">    quicklistNode *new_node = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node, fill, sz)) &#123;</span><br><span class="line">        full = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (after &amp;&amp; (entry-&gt;offset == node-&gt;count - <span class="number">1</span> || entry-&gt;offset == <span class="number">-1</span>)) &#123;</span><br><span class="line">        at_tail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) &#123;</span><br><span class="line">            avail_next = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要解释一下 full、at_tail、avail_next 这几个变量的意思：full &#x3D;1 是说锚点元素所在的 quicklistNode 节点不能插入新元素了；at_tail &#x3D;1，是说要在锚节点尾部插入新元素；avail_next &#x3D; 1 是说锚节点的下一个节点，还有空间插入新元素，这种情况呢，一般是在 full、after、at_tail 三个值都是 1 的时候，才会考虑把新元素插入到下一个节点的头部。</p>
<p>上述这两个 if 代码块，就是在确定这三个值，先是检查锚节点的空间，然后是看锚点元素在 listpack 的位置，再就是下一个节点的空间。</p>
<p>接下来这个 if 分支是检查大元素的，不多说了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="type">void</span> _quicklistInsert(quicklistIter *iter, quicklistEntry *entry,</span><br><span class="line">                                   <span class="type">void</span> *value, <span class="type">const</span> <span class="type">size_t</span> sz, <span class="type">int</span> after)</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(isLargeElement(sz))) &#123;</span><br><span class="line">        ... <span class="comment">// 处理大元素插入的逻辑</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 省略其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面进入一个非常长的 if else 代码块，我们还是紧抓 after 插入场景进行分析，我这里标了 1 到 4，四个分支，这四个是和 after 插入场景相关的分支。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5b16c3470d4b83b3dd89bb809786a7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>我们一个个场景来说，来看这张图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a03d97c1f1cd4bccacaf93050e15d506~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>第一个场景，是锚节点没满，直接走 listpack 的定点插入逻辑就行。</p>
</li>
<li><p>第二个场景，是锚点满了，但是下一个节点还有空间，而且我们的锚点元素恰好在锚节点的结尾，那我在下一个 quicklistNode 节点的开头插入新元素，这也算是紧跟在锚点元素之后。</p>
</li>
<li><p>第三个场景是这样，锚点和下一个节点都满了，那没办法了，就只能创建一个新节点，然后插入到锚节点之后，然后把新元素存到这个新节点里面。</p>
</li>
<li><p>第四个场景里面呢，是锚节点满了，但是锚点元素不再节点尾部，这个时候就要把锚节点分裂成两个节点，然后再插入新元素。</p>
</li>
</ul>
<p>我们回到代码里面，看看这些分支里面注意的地方。</p>
<ul>
<li><p>第一个注意的地方是，<strong>解压节点和压缩节点这两个操作是成对出现的</strong>，比如说第一个场景里面，就是先解压，设置 recompress 值，然后插入新元素，最后再压缩节点。</p>
</li>
<li><p>第二个是场景 3 里面，插入新节点之后，新节点里面就只存了一个新元素，觉得多多少少有点浪费，但是也没有办法。</p>
</li>
<li><p>最后是场景 4 里面，锚节点分裂的位置，是新元素插入的位置。节点分裂的时候，可能会出现一种合并的情况。举个例子，就像下面这张图，锚节点分裂成两个节点之后，分裂出来的前面这个节点，可能会和前一个节点合并，当然，前提是这两个节点的数据合并之后，依旧没有达到分裂的阈值。具体的合并实现，在 _quicklistMergeNodes() 这个函数里面，里面会涉及到节点解压、listpack 合并这些事情，就留给小伙伴们自己分析了。</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8ddf9a3b4c4c79ba110db6ef0c3eed~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="弹出数据"><a href="#弹出数据" class="headerlink" title="弹出数据"></a>弹出数据</h2><p>从 quicklist 里面读取数据的时候，我们一般是从 quicklist 两端弹出数据，也就是 LPOP、RPOP 这种命令。这些 POP 命令底层依赖是 <code>PopCustom 这个函数</code>，我们用调用链视图看一眼，不仅是 LPOP、RPOP 命令，像阻塞版本里的 POP、LMOVE 这些命令也都是通过 quicklistPopCustom() 弹出元素的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11b4a150b204cd29fd36215f52d234c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>quicklistPopCustom() 函数基本就是前面说的 quicklistPushTail()、quicklistPushHead() 函数的反逻辑</strong>，先来看它的函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="type">int</span> where, <span class="type">unsigned</span> <span class="type">char</span> **data,</span></span><br><span class="line"><span class="params">                       <span class="type">size_t</span> *sz, <span class="type">long</span> <span class="type">long</span> *sval,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *(*saver)(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> sz))</span> </span><br></pre></td></tr></table></figure>

<p>这里的 where 参数是决定从队头还是队尾弹出数据，后面的两组输出参数，用来存弹出的元素值。要是这个值是字符串的时候，就用 data 和 sz，要是数字的话，就用 sval 存。最后的 saver 是一个函数指针，函数指针是个什么东西呢？如果小伙伴了解 Java，其实可以对标到 Java 里面的 Funtion 对象。</p>
<p>我简单再展开说一下这个<code>函数指针</code>怎么看哈。先看括号里面，saver 前面有个 * 号，说明它是一个指针类型；然后再看括号前面，void * 是说 saver 指向的这个函数返回一个 void 指针，void 指针呢，可以接任何类型的指针，是不是和 Java 里面的 Object 变量的感觉有点类似，可以接任何类型的对象；再看括号后面，这就是 saver 这个函数的参数列表。这么看完之后，是不是感觉 save 和 Java 里面的 BiFunction 很像了呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*saver)(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> sz)</span><br><span class="line"></span><br><span class="line">BiFunction&lt;String, Integer, R&gt; bf = ...</span><br></pre></td></tr></table></figure>

<p>看完 quicklistPopCustom() 函数的参数列表之后，我们再来看它的具体实现脉络。</p>
<p>这里先是根据 where 参数确定从头还是尾弹出元素，然后是针对一个节点存一个大元素的特殊处理分支，最后是从 listpack 里面找正常元素返回的处理分支，该分支找到元素之后，就根据元素类型，把元素值存到 data 或是 sval 里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="type">int</span> where, <span class="type">unsigned</span> <span class="type">char</span> **data,</span></span><br><span class="line"><span class="params">                       <span class="type">size_t</span> *sz, <span class="type">long</span> <span class="type">long</span> *sval,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *(*saver)(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> sz))</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line">    <span class="type">int</span> pos = (where == QUICKLIST_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sval)</span><br><span class="line">        *sval = <span class="number">-123456789</span>;</span><br><span class="line"></span><br><span class="line">    quicklistNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定从头还是从尾弹出元素</span></span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</span><br><span class="line">        node = quicklist-&gt;head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</span><br><span class="line">        node = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(QL_NODE_IS_PLAIN(node))) &#123; <span class="comment">// 针对大元素的特殊处理分支</span></span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            *data = saver(node-&gt;entry, node-&gt;sz);</span><br><span class="line">        <span class="keyword">if</span> (sz)</span><br><span class="line">            *sz = node-&gt;sz;</span><br><span class="line">        quicklistDelIndex(quicklist, node, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回正常元素返回的分支：从listpack里面找元素，pos决定了是从头还是尾</span></span><br><span class="line">    p = lpSeek(node-&gt;entry, pos);</span><br><span class="line">    vstr = lpGetValue(p, &amp;vlen, &amp;vlong);</span><br><span class="line">    <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            *data = saver(vstr, vlen);</span><br><span class="line">        <span class="keyword">if</span> (sz)</span><br><span class="line">            *sz = vlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            *data = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (sval)</span><br><span class="line">            *sval = vlong;</span><br><span class="line">    &#125;</span><br><span class="line">    quicklistDelIndex(quicklist, node, &amp;p); <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查完元素之后呢，就要开始处理 “弹出” 操作里面删除元素的操作了。执行 <code>quicklistDelIndex() </code>这个函数，你可以进入该函数看一下，它先是大元素的处理分支，逻辑是直接删节点；然后是小元素的处理分支，逻辑就是从 listpack 里面删，listpack 删干净之后，就开始删整个 quicklistNode 节点。在删节点的时候，需要注意一下，里面会调用 __quicklistCompress() 函数，让整个 quicklist 重新满足 list-compress-depth 参数的压缩深度。</p>
<p>最后，<code>quicklistDelRange() </code>这个函数，也有删除数据的效果，而且是删除一个范围内的元素，它是 LTRIM 命令的底层实现，具体实现就留给小伙伴自己分析了，相信问题不大。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>说完插入和弹出数据的逻辑之后，我们最后来看如何遍历整个 quicklist，也就是 quicklist 迭代器内容。</p>
<p>我们 Java 里面是怎么使用迭代器的呢？模板代码就是先创建一个迭代器，然后循环迭代，循环到合适的目标元素就进行处理，比如下面的打印、删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = Lists.newArrayList();</span><br><span class="line">Iterator&lt;String&gt; iterator = <span class="built_in">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String s = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;target&quot;</span>.equals(s)) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 quicklist 迭代器的话，也是类似的模板代码，流程大致如下：先创建 quicklist 迭代器，然后通过 quicklistNext() 推进迭代器，迭代到的元素会记录到 entry 里面，在这个 whlie 循环里面，就是去读 entry 里面的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">quicklistIter *iter = quicklistGetIterator(quicklist,&lt;direction&gt;);</span><br><span class="line">quicklistEntry entry;</span><br><span class="line"><span class="keyword">while</span> (quicklistNext(iter, &amp;entry)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.value)</span><br><span class="line">      [[ use entry.value with entry.sz ]]</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      [[ use entry.longval ]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建 quicklistIter 的话，有两个函数：一个是 quicklistGetIterator() 函数，它返回的迭代器是从 quicklist 的头或尾开始迭代的；另一个是 quicklistGetIteratorAtIdx() 函数，它返回的迭代器是从一个指定位置开始迭代。</p>
<p><strong>这两个函数主要是初始化了 quicklist 迭代器的 current 和 offset 字段</strong>。以 quicklistGetIteratorAtIdx() 函数为例，如下图，我们需要从第 9 个元素开始正向迭代的话，就需要把迭代器的 current 指针移动到第 3 个节点，offset 移动到 current 节点里面的第二个元素。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1b94eeea104f998ee5750d56bf92de~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>具体的实现就不展开分析了，小伙伴们可以自行思考一下。</p>
<p>创建完 quicklist 迭代器，再来看 quicklistNext() 函数是怎么推进迭代器的，核心代码和注释如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> &#123;</span><br><span class="line">    ... <span class="comment">// 省略初始化entry以及检查iter迭代器的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *(*nextFn)(<span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">unsigned</span> <span class="type">char</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> offset_update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> plain = QL_NODE_IS_PLAIN(iter-&gt;current);</span><br><span class="line">    <span class="comment">// 下面初始化iter-&gt;zi字段</span></span><br><span class="line">    <span class="keyword">if</span> (!iter-&gt;zi) &#123; <span class="comment">// 当前zi为空，说明上一个节点的内容已经迭代完毕了，需要解压current节点开始迭代了</span></span><br><span class="line">        quicklistDecompressNodeForUse(iter-&gt;current); <span class="comment">// 解压节点内容</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(plain)) <span class="comment">// 大元素处理分支</span></span><br><span class="line">            iter-&gt;zi = iter-&gt;current-&gt;entry;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 正常元素处理分支</span></span><br><span class="line">            iter-&gt;zi = lpSeek(iter-&gt;current-&gt;entry, iter-&gt;offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(plain)) &#123; </span><br><span class="line">        <span class="comment">// 对大元素的处理，zi在下次quicklistNext()的时候，指向下个节点的listpack了，这里还是保持NULL就行了</span></span><br><span class="line">        iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前迭代器在PACKED类型的节点中迭代，现在要推进到下一个元素</span></span><br><span class="line">        <span class="comment">// 注意，这里有个特殊情况，那就是当前已经迭代到了该节点listpack的结尾，再继续推进的话，zi指针就是NULL了，</span></span><br><span class="line">        <span class="comment">// 下面会有专门的逻辑来处理这种特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            nextFn = lpNext;</span><br><span class="line">            offset_update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            nextFn = lpPrev;</span><br><span class="line">            offset_update = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter-&gt;zi = nextFn(iter-&gt;current-&gt;entry, iter-&gt;zi);</span><br><span class="line">        iter-&gt;offset += offset_update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定了zi指向的元素之后，就开始把元素值填到entry里面了。</span></span><br><span class="line">    entry-&gt;zi = iter-&gt;zi;</span><br><span class="line">    entry-&gt;offset = iter-&gt;offset;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;zi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(plain)) &#123;</span><br><span class="line">            entry-&gt;value = entry-&gt;node-&gt;entry;</span><br><span class="line">            entry-&gt;sz = entry-&gt;node-&gt;sz;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        entry-&gt;value = lpGetValue(entry-&gt;zi, &amp;sz, &amp;entry-&gt;longval);</span><br><span class="line">        entry-&gt;sz = sz;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这是处理zi指针为NULL的特殊情况，此时说明当前这个节点里面的元素都迭代完了，</span></span><br><span class="line">        <span class="comment">// 所以需要迭代下一个节点，所以current需要后移，offset设置成0。</span></span><br><span class="line">        <span class="comment">// 同时将刚迭代完的这个节点压缩重新压缩起来，然后再调一次quicklistNext()，</span></span><br><span class="line">        <span class="comment">// 就可以迭代出下一个节点的第一个元素了。</span></span><br><span class="line">        quicklistCompress(iter-&gt;quicklist, iter-&gt;current);</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            iter-&gt;current = iter-&gt;current-&gt;next;</span><br><span class="line">            iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            iter-&gt;current = iter-&gt;current-&gt;prev;</span><br><span class="line">            iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> quicklistNext(iter, entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里，还有两个地方要说一下：</p>
<ul>
<li><p>一个是在 quicklistNext() 函数里面，刚开始迭代一个节点的时候，如果该节点之前是压缩节点的话，会先解压这个节点，迭代完这个节点之后，会立刻把它再压缩起来；</p>
</li>
<li><p>第二个地方是，插入元素和更新元素的时候，会把迭代器关掉，就是 resetIterator 这个宏，里面就是把 current 设置成 NULL，这个迭代器就没法用了。但是要注意，删除的时候，不会销毁迭代器，你可以看到 quicklistDelEntry() 函数里面是没有调 reset 销毁迭代器。</p>
</li>
</ul>
<p>最后，还有 quicklist 的删除逻辑，其实就是前面说的 quicklistDelIndex() 函数，它也是 LREM 命令的核心实现，这里就不重复了哈。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本节中，我们重点介绍了 quicklist 的核心函数。</p>
<p>首先我们介绍了初始化 quicklist 实例的函数，然后详细分析了向 quicklist 头部（或尾部）插入元素的逻辑，其中针对插入大元素、插入正常元素以及节点分裂三个分支进行了详细地分析。在节点分裂之后，可能会触发 quicklist 节点的压缩，所以接下来又对 quicklist 节点压缩的逻辑进行深入剖析。</p>
<p>分析完 quicklist 头部（或尾部）插入元素之后，我们展开介绍了在 quicklist 指定位置插入元素的 _quicklistInsert() 函数，根据插入位置的不同，分成了四种不同的插入场景。</p>
<p>最后，我们讲解了从 quicklist 中弹出元素以及使用迭代器迭代 quicklist 的原理和关键实现。</p>
<p>至此，整个 quicklist 的全部内容，也就介绍完了。下一节，我们接着开始介绍 Redis 里面的哈希结构。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io">Southblock</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5quicklist%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/">https://hutbzc.github.io/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5quicklist%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hutbzc.github.io" target="_blank">Southblock'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC18%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9Aquicklist%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC20%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5Hash%E5%AE%9E%E7%8E%B0/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://bu.dusays.com/2024/05/14/664353a6a5232.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Southblock</div><div class="author-info__description">个人博客Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hutbzc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hutbzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:southblock@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="/javascript;" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #26da6f;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Southblock' Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-quicklist"><span class="toc-number">1.</span> <span class="toc-text">创建 quicklist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-likely-%E4%B8%8E-unlikely"><span class="toc-number">2.1.</span> <span class="toc-text">1. likely 与 unlikely</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">2. 插入大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%AD%A3%E5%B8%B8%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.</span> <span class="toc-text">3. 插入正常元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">4. 节点分裂场景处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%8E%8B%E7%BC%A9%E9%80%BB%E8%BE%91"><span class="toc-number">3.</span> <span class="toc-text">节点压缩逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">4.</span> <span class="toc-text">指定位置插入数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">弹出数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">6.</span> <span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC66%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis%E6%89%A9%E5%B1%95%E5%88%A9%E5%99%A8%E4%B9%8BLua%E8%84%9A%E6%9C%AC/" title="无题">无题</a><time datetime="2026-02-05T16:11:32.431Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC67%E7%AB%A0%E2%80%94%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E7%AF%87%EF%BC%9ARedis7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BFunctions%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:11:32.431Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC68%E7%AB%A0%E2%80%94%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BC%9A%E7%82%B9%E4%BA%AE%E4%BD%A0%E7%9A%84Redis%E6%8A%80%E8%83%BD%E6%A0%91%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%99%8B%E5%8D%87%E4%B8%BA%E8%A1%8C%E4%B8%9A%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B/" title="无题">无题</a><time datetime="2026-02-05T16:11:32.431Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC58%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E4%B8%8Eslot%E5%88%86%E9%85%8D%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2026-02-05T16:11:32.430Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/05/course/%E8%AF%B4%E9%80%8FRedis7/%E7%AC%AC59%E7%AB%A0%E2%80%94Cluster%E7%AF%87%EF%BC%9ARedisCluster%E4%B8%AD%E7%9A%84failover%E5%8E%9F%E7%90%86/" title="无题">无题</a><time datetime="2026-02-05T16:11:32.430Z" title="发表于 2026-02-06 00:11:32">2026-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By Southblock</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>